
fingerprint14.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e8  00802000  00000fc6  0000105a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000021e  008020e8  008020e8  00001142  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001142  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001d0  00000000  00000000  00001172  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000032f9  00000000  00000000  00001342  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000da9  00000000  00000000  0000463b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001c12  00000000  00000000  000053e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000005dc  00000000  00000000  00006ff8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000bf6  00000000  00000000  000075d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002d20  00000000  00000000  000081ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001d0  00000000  00000000  0000aeea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
   2:	00 00       	nop
   4:	63 c2       	rjmp	.+1222   	; 0x4cc <__bad_interrupt>
   6:	00 00       	nop
   8:	61 c2       	rjmp	.+1218   	; 0x4cc <__bad_interrupt>
   a:	00 00       	nop
   c:	5f c2       	rjmp	.+1214   	; 0x4cc <__bad_interrupt>
   e:	00 00       	nop
  10:	5d c2       	rjmp	.+1210   	; 0x4cc <__bad_interrupt>
  12:	00 00       	nop
  14:	5b c2       	rjmp	.+1206   	; 0x4cc <__bad_interrupt>
  16:	00 00       	nop
  18:	59 c2       	rjmp	.+1202   	; 0x4cc <__bad_interrupt>
  1a:	00 00       	nop
  1c:	57 c2       	rjmp	.+1198   	; 0x4cc <__bad_interrupt>
  1e:	00 00       	nop
  20:	55 c2       	rjmp	.+1194   	; 0x4cc <__bad_interrupt>
  22:	00 00       	nop
  24:	53 c2       	rjmp	.+1190   	; 0x4cc <__bad_interrupt>
  26:	00 00       	nop
  28:	51 c2       	rjmp	.+1186   	; 0x4cc <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4f c2       	rjmp	.+1182   	; 0x4cc <__bad_interrupt>
  2e:	00 00       	nop
  30:	4d c2       	rjmp	.+1178   	; 0x4cc <__bad_interrupt>
  32:	00 00       	nop
  34:	4b c2       	rjmp	.+1174   	; 0x4cc <__bad_interrupt>
  36:	00 00       	nop
  38:	49 c2       	rjmp	.+1170   	; 0x4cc <__bad_interrupt>
  3a:	00 00       	nop
  3c:	47 c2       	rjmp	.+1166   	; 0x4cc <__bad_interrupt>
  3e:	00 00       	nop
  40:	45 c2       	rjmp	.+1162   	; 0x4cc <__bad_interrupt>
  42:	00 00       	nop
  44:	43 c2       	rjmp	.+1158   	; 0x4cc <__bad_interrupt>
  46:	00 00       	nop
  48:	41 c2       	rjmp	.+1154   	; 0x4cc <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3f c2       	rjmp	.+1150   	; 0x4cc <__bad_interrupt>
  4e:	00 00       	nop
  50:	3d c2       	rjmp	.+1146   	; 0x4cc <__bad_interrupt>
  52:	00 00       	nop
  54:	3b c2       	rjmp	.+1142   	; 0x4cc <__bad_interrupt>
  56:	00 00       	nop
  58:	39 c2       	rjmp	.+1138   	; 0x4cc <__bad_interrupt>
  5a:	00 00       	nop
  5c:	37 c2       	rjmp	.+1134   	; 0x4cc <__bad_interrupt>
  5e:	00 00       	nop
  60:	35 c2       	rjmp	.+1130   	; 0x4cc <__bad_interrupt>
  62:	00 00       	nop
  64:	33 c2       	rjmp	.+1126   	; 0x4cc <__bad_interrupt>
  66:	00 00       	nop
  68:	31 c2       	rjmp	.+1122   	; 0x4cc <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2f c2       	rjmp	.+1118   	; 0x4cc <__bad_interrupt>
  6e:	00 00       	nop
  70:	2d c2       	rjmp	.+1114   	; 0x4cc <__bad_interrupt>
  72:	00 00       	nop
  74:	2b c2       	rjmp	.+1110   	; 0x4cc <__bad_interrupt>
  76:	00 00       	nop
  78:	29 c2       	rjmp	.+1106   	; 0x4cc <__bad_interrupt>
  7a:	00 00       	nop
  7c:	27 c2       	rjmp	.+1102   	; 0x4cc <__bad_interrupt>
  7e:	00 00       	nop
  80:	25 c2       	rjmp	.+1098   	; 0x4cc <__bad_interrupt>
  82:	00 00       	nop
  84:	23 c2       	rjmp	.+1094   	; 0x4cc <__bad_interrupt>
  86:	00 00       	nop
  88:	21 c2       	rjmp	.+1090   	; 0x4cc <__bad_interrupt>
  8a:	00 00       	nop
  8c:	1f c2       	rjmp	.+1086   	; 0x4cc <__bad_interrupt>
  8e:	00 00       	nop
  90:	1d c2       	rjmp	.+1082   	; 0x4cc <__bad_interrupt>
  92:	00 00       	nop
  94:	1b c2       	rjmp	.+1078   	; 0x4cc <__bad_interrupt>
  96:	00 00       	nop
  98:	19 c2       	rjmp	.+1074   	; 0x4cc <__bad_interrupt>
  9a:	00 00       	nop
  9c:	17 c2       	rjmp	.+1070   	; 0x4cc <__bad_interrupt>
  9e:	00 00       	nop
  a0:	15 c2       	rjmp	.+1066   	; 0x4cc <__bad_interrupt>
  a2:	00 00       	nop
  a4:	13 c2       	rjmp	.+1062   	; 0x4cc <__bad_interrupt>
  a6:	00 00       	nop
  a8:	11 c2       	rjmp	.+1058   	; 0x4cc <__bad_interrupt>
  aa:	00 00       	nop
  ac:	0f c2       	rjmp	.+1054   	; 0x4cc <__bad_interrupt>
  ae:	00 00       	nop
  b0:	0d c2       	rjmp	.+1050   	; 0x4cc <__bad_interrupt>
  b2:	00 00       	nop
  b4:	0b c2       	rjmp	.+1046   	; 0x4cc <__bad_interrupt>
  b6:	00 00       	nop
  b8:	09 c2       	rjmp	.+1042   	; 0x4cc <__bad_interrupt>
  ba:	00 00       	nop
  bc:	07 c2       	rjmp	.+1038   	; 0x4cc <__bad_interrupt>
  be:	00 00       	nop
  c0:	05 c2       	rjmp	.+1034   	; 0x4cc <__bad_interrupt>
  c2:	00 00       	nop
  c4:	03 c2       	rjmp	.+1030   	; 0x4cc <__bad_interrupt>
  c6:	00 00       	nop
  c8:	01 c2       	rjmp	.+1026   	; 0x4cc <__bad_interrupt>
  ca:	00 00       	nop
  cc:	ff c1       	rjmp	.+1022   	; 0x4cc <__bad_interrupt>
  ce:	00 00       	nop
  d0:	fd c1       	rjmp	.+1018   	; 0x4cc <__bad_interrupt>
  d2:	00 00       	nop
  d4:	fb c1       	rjmp	.+1014   	; 0x4cc <__bad_interrupt>
  d6:	00 00       	nop
  d8:	f9 c1       	rjmp	.+1010   	; 0x4cc <__bad_interrupt>
  da:	00 00       	nop
  dc:	f7 c1       	rjmp	.+1006   	; 0x4cc <__bad_interrupt>
  de:	00 00       	nop
  e0:	f5 c1       	rjmp	.+1002   	; 0x4cc <__bad_interrupt>
  e2:	00 00       	nop
  e4:	f3 c1       	rjmp	.+998    	; 0x4cc <__bad_interrupt>
  e6:	00 00       	nop
  e8:	f1 c1       	rjmp	.+994    	; 0x4cc <__bad_interrupt>
  ea:	00 00       	nop
  ec:	ef c1       	rjmp	.+990    	; 0x4cc <__bad_interrupt>
  ee:	00 00       	nop
  f0:	ed c1       	rjmp	.+986    	; 0x4cc <__bad_interrupt>
  f2:	00 00       	nop
  f4:	eb c1       	rjmp	.+982    	; 0x4cc <__bad_interrupt>
  f6:	00 00       	nop
  f8:	e9 c1       	rjmp	.+978    	; 0x4cc <__bad_interrupt>
  fa:	00 00       	nop
  fc:	e7 c1       	rjmp	.+974    	; 0x4cc <__bad_interrupt>
  fe:	00 00       	nop
 100:	e5 c1       	rjmp	.+970    	; 0x4cc <__bad_interrupt>
 102:	00 00       	nop
 104:	e3 c1       	rjmp	.+966    	; 0x4cc <__bad_interrupt>
 106:	00 00       	nop
 108:	e1 c1       	rjmp	.+962    	; 0x4cc <__bad_interrupt>
 10a:	00 00       	nop
 10c:	df c1       	rjmp	.+958    	; 0x4cc <__bad_interrupt>
 10e:	00 00       	nop
 110:	dd c1       	rjmp	.+954    	; 0x4cc <__bad_interrupt>
 112:	00 00       	nop
 114:	db c1       	rjmp	.+950    	; 0x4cc <__bad_interrupt>
 116:	00 00       	nop
 118:	d9 c1       	rjmp	.+946    	; 0x4cc <__bad_interrupt>
 11a:	00 00       	nop
 11c:	d7 c1       	rjmp	.+942    	; 0x4cc <__bad_interrupt>
 11e:	00 00       	nop
 120:	d5 c1       	rjmp	.+938    	; 0x4cc <__bad_interrupt>
 122:	00 00       	nop
 124:	d3 c1       	rjmp	.+934    	; 0x4cc <__bad_interrupt>
 126:	00 00       	nop
 128:	d1 c1       	rjmp	.+930    	; 0x4cc <__bad_interrupt>
 12a:	00 00       	nop
 12c:	cf c1       	rjmp	.+926    	; 0x4cc <__bad_interrupt>
 12e:	00 00       	nop
 130:	cd c1       	rjmp	.+922    	; 0x4cc <__bad_interrupt>
 132:	00 00       	nop
 134:	cb c1       	rjmp	.+918    	; 0x4cc <__bad_interrupt>
 136:	00 00       	nop
 138:	c9 c1       	rjmp	.+914    	; 0x4cc <__bad_interrupt>
 13a:	00 00       	nop
 13c:	c7 c1       	rjmp	.+910    	; 0x4cc <__bad_interrupt>
 13e:	00 00       	nop
 140:	c5 c1       	rjmp	.+906    	; 0x4cc <__bad_interrupt>
 142:	00 00       	nop
 144:	c3 c1       	rjmp	.+902    	; 0x4cc <__bad_interrupt>
 146:	00 00       	nop
 148:	c1 c1       	rjmp	.+898    	; 0x4cc <__bad_interrupt>
 14a:	00 00       	nop
 14c:	bf c1       	rjmp	.+894    	; 0x4cc <__bad_interrupt>
 14e:	00 00       	nop
 150:	bd c1       	rjmp	.+890    	; 0x4cc <__bad_interrupt>
 152:	00 00       	nop
 154:	bb c1       	rjmp	.+886    	; 0x4cc <__bad_interrupt>
 156:	00 00       	nop
 158:	b9 c1       	rjmp	.+882    	; 0x4cc <__bad_interrupt>
 15a:	00 00       	nop
 15c:	b7 c1       	rjmp	.+878    	; 0x4cc <__bad_interrupt>
 15e:	00 00       	nop
 160:	b5 c1       	rjmp	.+874    	; 0x4cc <__bad_interrupt>
 162:	00 00       	nop
 164:	b3 c1       	rjmp	.+870    	; 0x4cc <__bad_interrupt>
 166:	00 00       	nop
 168:	b1 c1       	rjmp	.+866    	; 0x4cc <__bad_interrupt>
 16a:	00 00       	nop
 16c:	af c1       	rjmp	.+862    	; 0x4cc <__bad_interrupt>
 16e:	00 00       	nop
 170:	ad c1       	rjmp	.+858    	; 0x4cc <__bad_interrupt>
 172:	00 00       	nop
 174:	ab c1       	rjmp	.+854    	; 0x4cc <__bad_interrupt>
 176:	00 00       	nop
 178:	a9 c1       	rjmp	.+850    	; 0x4cc <__bad_interrupt>
 17a:	00 00       	nop
 17c:	a7 c1       	rjmp	.+846    	; 0x4cc <__bad_interrupt>
 17e:	00 00       	nop
 180:	a5 c1       	rjmp	.+842    	; 0x4cc <__bad_interrupt>
 182:	00 00       	nop
 184:	a3 c1       	rjmp	.+838    	; 0x4cc <__bad_interrupt>
 186:	00 00       	nop
 188:	a1 c1       	rjmp	.+834    	; 0x4cc <__bad_interrupt>
 18a:	00 00       	nop
 18c:	9f c1       	rjmp	.+830    	; 0x4cc <__bad_interrupt>
 18e:	00 00       	nop
 190:	9d c1       	rjmp	.+826    	; 0x4cc <__bad_interrupt>
 192:	00 00       	nop
 194:	9b c1       	rjmp	.+822    	; 0x4cc <__bad_interrupt>
 196:	00 00       	nop
 198:	99 c1       	rjmp	.+818    	; 0x4cc <__bad_interrupt>
 19a:	00 00       	nop
 19c:	97 c1       	rjmp	.+814    	; 0x4cc <__bad_interrupt>
 19e:	00 00       	nop
 1a0:	95 c1       	rjmp	.+810    	; 0x4cc <__bad_interrupt>
 1a2:	00 00       	nop
 1a4:	93 c1       	rjmp	.+806    	; 0x4cc <__bad_interrupt>
 1a6:	00 00       	nop
 1a8:	91 c1       	rjmp	.+802    	; 0x4cc <__bad_interrupt>
 1aa:	00 00       	nop
 1ac:	8f c1       	rjmp	.+798    	; 0x4cc <__bad_interrupt>
 1ae:	00 00       	nop
 1b0:	8d c1       	rjmp	.+794    	; 0x4cc <__bad_interrupt>
 1b2:	00 00       	nop
 1b4:	8b c1       	rjmp	.+790    	; 0x4cc <__bad_interrupt>
 1b6:	00 00       	nop
 1b8:	89 c1       	rjmp	.+786    	; 0x4cc <__bad_interrupt>
 1ba:	00 00       	nop
 1bc:	87 c1       	rjmp	.+782    	; 0x4cc <__bad_interrupt>
 1be:	00 00       	nop
 1c0:	85 c1       	rjmp	.+778    	; 0x4cc <__bad_interrupt>
 1c2:	00 00       	nop
 1c4:	83 c1       	rjmp	.+774    	; 0x4cc <__bad_interrupt>
 1c6:	00 00       	nop
 1c8:	81 c1       	rjmp	.+770    	; 0x4cc <__bad_interrupt>
 1ca:	00 00       	nop
 1cc:	7f c1       	rjmp	.+766    	; 0x4cc <__bad_interrupt>
 1ce:	00 00       	nop
 1d0:	7d c1       	rjmp	.+762    	; 0x4cc <__bad_interrupt>
 1d2:	00 00       	nop
 1d4:	7b c1       	rjmp	.+758    	; 0x4cc <__bad_interrupt>
 1d6:	00 00       	nop
 1d8:	79 c1       	rjmp	.+754    	; 0x4cc <__bad_interrupt>
 1da:	00 00       	nop
 1dc:	77 c1       	rjmp	.+750    	; 0x4cc <__bad_interrupt>
 1de:	00 00       	nop
 1e0:	75 c1       	rjmp	.+746    	; 0x4cc <__bad_interrupt>
 1e2:	00 00       	nop
 1e4:	73 c1       	rjmp	.+742    	; 0x4cc <__bad_interrupt>
 1e6:	00 00       	nop
 1e8:	71 c1       	rjmp	.+738    	; 0x4cc <__bad_interrupt>
 1ea:	00 00       	nop
 1ec:	6f c1       	rjmp	.+734    	; 0x4cc <__bad_interrupt>
 1ee:	00 00       	nop
 1f0:	6d c1       	rjmp	.+730    	; 0x4cc <__bad_interrupt>
 1f2:	00 00       	nop
 1f4:	6b c1       	rjmp	.+726    	; 0x4cc <__bad_interrupt>
 1f6:	00 00       	nop
 1f8:	69 c1       	rjmp	.+722    	; 0x4cc <__bad_interrupt>
	...

000001fc <__trampolines_end>:
 1fc:	00 00       	nop
 1fe:	00 00       	nop
 200:	00 00       	nop
 202:	00 20       	and	r0, r0
 204:	20 20       	and	r2, r0
 206:	20 20       	and	r2, r0
 208:	00 20       	and	r0, r0
 20a:	50 50       	subi	r21, 0x00	; 0
 20c:	50 00       	.word	0x0050	; ????
 20e:	00 00       	nop
 210:	00 50       	subi	r16, 0x00	; 0
 212:	50 f8       	bld	r5, 0
 214:	50 f8       	bld	r5, 0
 216:	50 50       	subi	r21, 0x00	; 0
 218:	20 78       	andi	r18, 0x80	; 128
 21a:	a0 70       	andi	r26, 0x00	; 0
 21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
 21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
 220:	c8 10       	cpse	r12, r8
 222:	20 40       	sbci	r18, 0x00	; 0
 224:	98 18       	sub	r9, r8
 226:	60 90 a0 40 	lds	r6, 0x40A0
 22a:	a8 90       	.word	0x90a8	; ????
 22c:	68 60       	ori	r22, 0x08	; 8
 22e:	20 40       	sbci	r18, 0x00	; 0
 230:	00 00       	nop
 232:	00 00       	nop
 234:	10 20       	and	r1, r0
 236:	40 40       	sbci	r20, 0x00	; 0
 238:	40 20       	and	r4, r0
 23a:	10 40       	sbci	r17, 0x00	; 0
 23c:	20 10       	cpse	r2, r0
 23e:	10 10       	cpse	r1, r0
 240:	20 40       	sbci	r18, 0x00	; 0
 242:	00 50       	subi	r16, 0x00	; 0
 244:	20 f8       	bld	r2, 0
 246:	20 50       	subi	r18, 0x00	; 0
 248:	00 00       	nop
 24a:	20 20       	and	r2, r0
 24c:	f8 20       	and	r15, r8
 24e:	20 00       	.word	0x0020	; ????
 250:	00 00       	nop
 252:	00 00       	nop
 254:	60 20       	and	r6, r0
 256:	40 00       	.word	0x0040	; ????
 258:	00 00       	nop
 25a:	f8 00       	.word	0x00f8	; ????
 25c:	00 00       	nop
 25e:	00 00       	nop
 260:	00 00       	nop
 262:	00 60       	ori	r16, 0x00	; 0
 264:	60 00       	.word	0x0060	; ????
 266:	08 10       	cpse	r0, r8
 268:	20 40       	sbci	r18, 0x00	; 0
 26a:	80 00       	.word	0x0080	; ????
 26c:	70 88       	ldd	r7, Z+16	; 0x10
 26e:	98 a8       	ldd	r9, Y+48	; 0x30
 270:	c8 88       	ldd	r12, Y+16	; 0x10
 272:	70 20       	and	r7, r0
 274:	60 20       	and	r6, r0
 276:	20 20       	and	r2, r0
 278:	20 70       	andi	r18, 0x00	; 0
 27a:	70 88       	ldd	r7, Z+16	; 0x10
 27c:	08 10       	cpse	r0, r8
 27e:	20 40       	sbci	r18, 0x00	; 0
 280:	f8 f8       	.word	0xf8f8	; ????
 282:	10 20       	and	r1, r0
 284:	10 08       	sbc	r1, r0
 286:	88 70       	andi	r24, 0x08	; 8
 288:	10 30       	cpi	r17, 0x00	; 0
 28a:	50 90 f8 10 	lds	r5, 0x10F8
 28e:	10 f8       	bld	r1, 0
 290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
 292:	08 08       	sbc	r0, r8
 294:	88 70       	andi	r24, 0x08	; 8
 296:	30 40       	sbci	r19, 0x00	; 0
 298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
 29a:	88 88       	ldd	r8, Y+16	; 0x10
 29c:	70 f8       	bld	r7, 0
 29e:	08 10       	cpse	r0, r8
 2a0:	20 40       	sbci	r18, 0x00	; 0
 2a2:	40 40       	sbci	r20, 0x00	; 0
 2a4:	70 88       	ldd	r7, Z+16	; 0x10
 2a6:	88 70       	andi	r24, 0x08	; 8
 2a8:	88 88       	ldd	r8, Y+16	; 0x10
 2aa:	70 70       	andi	r23, 0x00	; 0
 2ac:	88 88       	ldd	r8, Y+16	; 0x10
 2ae:	78 08       	sbc	r7, r8
 2b0:	10 60       	ori	r17, 0x00	; 0
 2b2:	00 60       	ori	r16, 0x00	; 0
 2b4:	60 00       	.word	0x0060	; ????
 2b6:	60 60       	ori	r22, 0x00	; 0
 2b8:	00 00       	nop
 2ba:	60 60       	ori	r22, 0x00	; 0
 2bc:	00 60       	ori	r16, 0x00	; 0
 2be:	20 40       	sbci	r18, 0x00	; 0
 2c0:	08 10       	cpse	r0, r8
 2c2:	20 40       	sbci	r18, 0x00	; 0
 2c4:	20 10       	cpse	r2, r0
 2c6:	08 00       	.word	0x0008	; ????
 2c8:	00 f8       	bld	r0, 0
 2ca:	00 f8       	bld	r0, 0
 2cc:	00 00       	nop
 2ce:	80 40       	sbci	r24, 0x00	; 0
 2d0:	20 10       	cpse	r2, r0
 2d2:	20 40       	sbci	r18, 0x00	; 0
 2d4:	80 70       	andi	r24, 0x00	; 0
 2d6:	88 08       	sbc	r8, r8
 2d8:	10 20       	and	r1, r0
 2da:	00 20       	and	r0, r0
 2dc:	70 88       	ldd	r7, Z+16	; 0x10
 2de:	08 68       	ori	r16, 0x88	; 136
 2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
 2e2:	70 70       	andi	r23, 0x00	; 0
 2e4:	88 88       	ldd	r8, Y+16	; 0x10
 2e6:	88 f8       	.word	0xf888	; ????
 2e8:	88 88       	ldd	r8, Y+16	; 0x10
 2ea:	f0 88       	ldd	r15, Z+16	; 0x10
 2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
 2ee:	88 88       	ldd	r8, Y+16	; 0x10
 2f0:	f0 70       	andi	r31, 0x00	; 0
 2f2:	88 80       	ld	r8, Y
 2f4:	80 80       	ld	r8, Z
 2f6:	88 70       	andi	r24, 0x08	; 8
 2f8:	e0 90 88 88 	lds	r14, 0x8888
 2fc:	88 90       	.word	0x9088	; ????
 2fe:	e0 f8       	bld	r14, 0
 300:	80 80       	ld	r8, Z
 302:	f0 80       	ld	r15, Z
 304:	80 f8       	bld	r8, 0
 306:	f8 80       	ld	r15, Y
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	80 80       	ld	r8, Z
 30c:	80 70       	andi	r24, 0x00	; 0
 30e:	88 80       	ld	r8, Y
 310:	80 98       	cbi	0x10, 0	; 16
 312:	88 70       	andi	r24, 0x08	; 8
 314:	88 88       	ldd	r8, Y+16	; 0x10
 316:	88 f8       	.word	0xf888	; ????
 318:	88 88       	ldd	r8, Y+16	; 0x10
 31a:	88 70       	andi	r24, 0x08	; 8
 31c:	20 20       	and	r2, r0
 31e:	20 20       	and	r2, r0
 320:	20 70       	andi	r18, 0x00	; 0
 322:	38 10       	cpse	r3, r8
 324:	10 10       	cpse	r1, r0
 326:	10 90 60 88 	lds	r1, 0x8860
 32a:	90 a0       	ldd	r9, Z+32	; 0x20
 32c:	c0 a0       	ldd	r12, Z+32	; 0x20
 32e:	90 88       	ldd	r9, Z+16	; 0x10
 330:	80 80       	ld	r8, Z
 332:	80 80       	ld	r8, Z
 334:	80 80       	ld	r8, Z
 336:	f8 88       	ldd	r15, Y+16	; 0x10
 338:	d8 a8       	ldd	r13, Y+48	; 0x30
 33a:	88 88       	ldd	r8, Y+16	; 0x10
 33c:	88 88       	ldd	r8, Y+16	; 0x10
 33e:	88 88       	ldd	r8, Y+16	; 0x10
 340:	c8 a8       	ldd	r12, Y+48	; 0x30
 342:	98 88       	ldd	r9, Y+16	; 0x10
 344:	88 70       	andi	r24, 0x08	; 8
 346:	88 88       	ldd	r8, Y+16	; 0x10
 348:	88 88       	ldd	r8, Y+16	; 0x10
 34a:	88 70       	andi	r24, 0x08	; 8
 34c:	f0 88       	ldd	r15, Z+16	; 0x10
 34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
 350:	80 80       	ld	r8, Z
 352:	80 70       	andi	r24, 0x00	; 0
 354:	88 88       	ldd	r8, Y+16	; 0x10
 356:	88 a8       	ldd	r8, Y+48	; 0x30
 358:	90 68       	ori	r25, 0x80	; 128
 35a:	f0 88       	ldd	r15, Z+16	; 0x10
 35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
 35e:	a0 90 88 78 	lds	r10, 0x7888
 362:	80 80       	ld	r8, Z
 364:	70 08       	sbc	r7, r0
 366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
 368:	f8 20       	and	r15, r8
 36a:	20 20       	and	r2, r0
 36c:	20 20       	and	r2, r0
 36e:	20 88       	ldd	r2, Z+16	; 0x10
 370:	88 88       	ldd	r8, Y+16	; 0x10
 372:	88 88       	ldd	r8, Y+16	; 0x10
 374:	88 70       	andi	r24, 0x08	; 8
 376:	88 88       	ldd	r8, Y+16	; 0x10
 378:	88 88       	ldd	r8, Y+16	; 0x10
 37a:	88 50       	subi	r24, 0x08	; 8
 37c:	20 88       	ldd	r2, Z+16	; 0x10
 37e:	88 88       	ldd	r8, Y+16	; 0x10
 380:	a8 a8       	ldd	r10, Y+48	; 0x30
 382:	d8 88       	ldd	r13, Y+16	; 0x10
 384:	88 88       	ldd	r8, Y+16	; 0x10
 386:	50 20       	and	r5, r0
 388:	50 88       	ldd	r5, Z+16	; 0x10
 38a:	88 88       	ldd	r8, Y+16	; 0x10
 38c:	88 50       	subi	r24, 0x08	; 8
 38e:	20 20       	and	r2, r0
 390:	20 20       	and	r2, r0
 392:	f8 08       	sbc	r15, r8
 394:	10 20       	and	r1, r0
 396:	40 80       	ld	r4, Z
 398:	f8 38       	cpi	r31, 0x88	; 136
 39a:	20 20       	and	r2, r0
 39c:	20 20       	and	r2, r0
 39e:	20 38       	cpi	r18, 0x80	; 128
 3a0:	00 80       	ld	r0, Z
 3a2:	40 20       	and	r4, r0
 3a4:	10 08       	sbc	r1, r0
 3a6:	00 e0       	ldi	r16, 0x00	; 0
 3a8:	20 20       	and	r2, r0
 3aa:	20 20       	and	r2, r0
 3ac:	20 e0       	ldi	r18, 0x00	; 0
 3ae:	20 50       	subi	r18, 0x00	; 0
 3b0:	88 00       	.word	0x0088	; ????
	...
 3ba:	00 f8       	bld	r0, 0
 3bc:	40 20       	and	r4, r0
 3be:	10 00       	.word	0x0010	; ????
 3c0:	00 00       	nop
 3c2:	00 00       	nop
 3c4:	00 70       	andi	r16, 0x00	; 0
 3c6:	08 78       	andi	r16, 0x88	; 136
 3c8:	88 78       	andi	r24, 0x88	; 136
 3ca:	80 80       	ld	r8, Z
 3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
 3ce:	88 88       	ldd	r8, Y+16	; 0x10
 3d0:	f0 00       	.word	0x00f0	; ????
 3d2:	00 70       	andi	r16, 0x00	; 0
 3d4:	80 80       	ld	r8, Z
 3d6:	88 70       	andi	r24, 0x08	; 8
 3d8:	08 08       	sbc	r0, r8
 3da:	68 98       	cbi	0x0d, 0	; 13
 3dc:	88 88       	ldd	r8, Y+16	; 0x10
 3de:	78 00       	.word	0x0078	; ????
 3e0:	00 70       	andi	r16, 0x00	; 0
 3e2:	88 f8       	.word	0xf888	; ????
 3e4:	80 70       	andi	r24, 0x00	; 0
 3e6:	30 48       	sbci	r19, 0x80	; 128
 3e8:	40 e0       	ldi	r20, 0x00	; 0
 3ea:	40 40       	sbci	r20, 0x00	; 0
 3ec:	40 00       	.word	0x0040	; ????
 3ee:	00 78       	andi	r16, 0x80	; 128
 3f0:	88 78       	andi	r24, 0x88	; 136
 3f2:	08 30       	cpi	r16, 0x08	; 8
 3f4:	80 80       	ld	r8, Z
 3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
 3f8:	88 88       	ldd	r8, Y+16	; 0x10
 3fa:	88 20       	and	r8, r8
 3fc:	00 60       	ori	r16, 0x00	; 0
 3fe:	20 20       	and	r2, r0
 400:	20 70       	andi	r18, 0x00	; 0
 402:	10 00       	.word	0x0010	; ????
 404:	30 10       	cpse	r3, r0
 406:	10 90 60 40 	lds	r1, 0x4060
 40a:	40 48       	sbci	r20, 0x80	; 128
 40c:	50 60       	ori	r21, 0x00	; 0
 40e:	50 48       	sbci	r21, 0x80	; 128
 410:	60 20       	and	r6, r0
 412:	20 20       	and	r2, r0
 414:	20 20       	and	r2, r0
 416:	70 00       	.word	0x0070	; ????
 418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
 41a:	a8 a8       	ldd	r10, Y+48	; 0x30
 41c:	88 88       	ldd	r8, Y+16	; 0x10
 41e:	00 00       	nop
 420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
 422:	88 88       	ldd	r8, Y+16	; 0x10
 424:	88 00       	.word	0x0088	; ????
 426:	00 70       	andi	r16, 0x00	; 0
 428:	88 88       	ldd	r8, Y+16	; 0x10
 42a:	88 70       	andi	r24, 0x08	; 8
 42c:	00 00       	nop
 42e:	f0 88       	ldd	r15, Z+16	; 0x10
 430:	f0 80       	ld	r15, Z
 432:	80 00       	.word	0x0080	; ????
 434:	00 68       	ori	r16, 0x80	; 128
 436:	98 78       	andi	r25, 0x88	; 136
 438:	08 08       	sbc	r0, r8
 43a:	00 00       	nop
 43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
 43e:	80 80       	ld	r8, Z
 440:	80 00       	.word	0x0080	; ????
 442:	00 70       	andi	r16, 0x00	; 0
 444:	80 70       	andi	r24, 0x00	; 0
 446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
 448:	40 40       	sbci	r20, 0x00	; 0
 44a:	e0 40       	sbci	r30, 0x00	; 0
 44c:	40 48       	sbci	r20, 0x80	; 128
 44e:	30 00       	.word	0x0030	; ????
 450:	00 88       	ldd	r0, Z+16	; 0x10
 452:	88 88       	ldd	r8, Y+16	; 0x10
 454:	98 68       	ori	r25, 0x88	; 136
 456:	00 00       	nop
 458:	88 88       	ldd	r8, Y+16	; 0x10
 45a:	88 50       	subi	r24, 0x08	; 8
 45c:	20 00       	.word	0x0020	; ????
 45e:	00 88       	ldd	r0, Z+16	; 0x10
 460:	88 a8       	ldd	r8, Y+48	; 0x30
 462:	a8 50       	subi	r26, 0x08	; 8
 464:	00 00       	nop
 466:	88 50       	subi	r24, 0x08	; 8
 468:	20 50       	subi	r18, 0x00	; 0
 46a:	88 00       	.word	0x0088	; ????
 46c:	00 88       	ldd	r0, Z+16	; 0x10
 46e:	88 78       	andi	r24, 0x88	; 136
 470:	08 70       	andi	r16, 0x08	; 8
 472:	00 00       	nop
 474:	f8 10       	cpse	r15, r8
 476:	20 40       	sbci	r18, 0x00	; 0
 478:	f8 10       	cpse	r15, r8
 47a:	20 20       	and	r2, r0
 47c:	40 20       	and	r4, r0
 47e:	20 10       	cpse	r2, r0
 480:	20 20       	and	r2, r0
 482:	20 20       	and	r2, r0
 484:	20 20       	and	r2, r0
 486:	20 40       	sbci	r18, 0x00	; 0
 488:	20 20       	and	r2, r0
 48a:	10 20       	and	r1, r0
 48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
 48e:	11 24       	eor	r1, r1
 490:	1f be       	out	0x3f, r1	; 63
 492:	cf ef       	ldi	r28, 0xFF	; 255
 494:	cd bf       	out	0x3d, r28	; 61
 496:	df e5       	ldi	r29, 0x5F	; 95
 498:	de bf       	out	0x3e, r29	; 62
 49a:	00 e0       	ldi	r16, 0x00	; 0
 49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
 49e:	10 e2       	ldi	r17, 0x20	; 32
 4a0:	a0 e0       	ldi	r26, 0x00	; 0
 4a2:	b0 e2       	ldi	r27, 0x20	; 32
 4a4:	e6 ec       	ldi	r30, 0xC6	; 198
 4a6:	ff e0       	ldi	r31, 0x0F	; 15
 4a8:	00 e0       	ldi	r16, 0x00	; 0
 4aa:	0b bf       	out	0x3b, r16	; 59
 4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
 4ae:	07 90       	elpm	r0, Z+
 4b0:	0d 92       	st	X+, r0
 4b2:	a8 3e       	cpi	r26, 0xE8	; 232
 4b4:	b1 07       	cpc	r27, r17
 4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
 4b8:	23 e2       	ldi	r18, 0x23	; 35
 4ba:	a8 ee       	ldi	r26, 0xE8	; 232
 4bc:	b0 e2       	ldi	r27, 0x20	; 32
 4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
 4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
 4c2:	a6 30       	cpi	r26, 0x06	; 6
 4c4:	b2 07       	cpc	r27, r18
 4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
 4c8:	35 d0       	rcall	.+106    	; 0x534 <main>
 4ca:	7b c5       	rjmp	.+2806   	; 0xfc2 <_exit>

000004cc <__bad_interrupt>:
 4cc:	99 cd       	rjmp	.-1230   	; 0x0 <__vectors>

000004ce <Set_Clk_32MHz>:
{  while(1)
   {  
		 if( *str == '\0' ) break;
      send_char(*str++);	    
   }
}
 4ce:	e0 e5       	ldi	r30, 0x50	; 80
 4d0:	f0 e0       	ldi	r31, 0x00	; 0
 4d2:	80 81       	ld	r24, Z
 4d4:	82 60       	ori	r24, 0x02	; 2
 4d6:	80 83       	st	Z, r24
 4d8:	e1 e5       	ldi	r30, 0x51	; 81
 4da:	f0 e0       	ldi	r31, 0x00	; 0
 4dc:	80 81       	ld	r24, Z
 4de:	81 ff       	sbrs	r24, 1
 4e0:	fd cf       	rjmp	.-6      	; 0x4dc <Set_Clk_32MHz+0xe>
 4e2:	88 ed       	ldi	r24, 0xD8	; 216
 4e4:	84 bf       	out	0x34, r24	; 52
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	80 93 40 00 	sts	0x0040, r24
 4ec:	08 95       	ret

000004ee <uart_init>:
 4ee:	88 e0       	ldi	r24, 0x08	; 8
 4f0:	80 93 45 06 	sts	0x0645, r24
 4f4:	80 93 41 06 	sts	0x0641, r24
 4f8:	8f ec       	ldi	r24, 0xCF	; 207
 4fa:	80 93 a6 08 	sts	0x08A6, r24
 4fe:	10 92 a7 08 	sts	0x08A7, r1
 502:	10 92 a3 08 	sts	0x08A3, r1
 506:	83 e0       	ldi	r24, 0x03	; 3
 508:	80 93 a5 08 	sts	0x08A5, r24
 50c:	88 e1       	ldi	r24, 0x18	; 24
 50e:	80 93 a4 08 	sts	0x08A4, r24
 512:	08 95       	ret

00000514 <send_char>:
 514:	80 93 a0 08 	sts	0x08A0, r24
 518:	e1 ea       	ldi	r30, 0xA1	; 161
 51a:	f8 e0       	ldi	r31, 0x08	; 8
 51c:	80 81       	ld	r24, Z
 51e:	85 ff       	sbrs	r24, 5
 520:	fd cf       	rjmp	.-6      	; 0x51c <send_char+0x8>
 522:	08 95       	ret

00000524 <receive_data>:
char receive_data(void)
{
	unsigned char c;
	
	//_delay_ms(100);
	while( !( USARTC0_STATUS & USART_RXCIF_bm) );
 524:	e1 ea       	ldi	r30, 0xA1	; 161
 526:	f8 e0       	ldi	r31, 0x08	; 8
 528:	80 81       	ld	r24, Z
 52a:	88 23       	and	r24, r24
 52c:	ec f7       	brge	.-6      	; 0x528 <receive_data+0x4>
	c=USARTC0_DATA;
 52e:	80 91 a0 08 	lds	r24, 0x08A0
	//USARTC0_STATUS |= USART_RXCIF_bm;   // Added by Mukesh

}
 532:	08 95       	ret

00000534 <main>:
/*-------------------------------------------------------------------------24.
main program
--------------------------------------------------------------------------*/
int main (void )
{
	PORTE_DIRSET=0xFF;
 534:	8f ef       	ldi	r24, 0xFF	; 255
 536:	80 93 81 06 	sts	0x0681, r24
	Set_Clk_32MHz();
 53a:	c9 df       	rcall	.-110    	; 0x4ce <Set_Clk_32MHz>
	//Init_LCD();
	uart_init();
 53c:	d8 df       	rcall	.-80     	; 0x4ee <uart_init>
	//receive_data();
	//_delay_ms(5000);
	//LCD_cmd(0x01);
	//_delay_ms(50);
	gfx_mono_init();
 53e:	1a d2       	rcall	.+1076   	; 0x974 <gfx_mono_st7565r_init>
	PORTA_DIRCLR=0x01;
 540:	81 e0       	ldi	r24, 0x01	; 1
 542:	80 93 02 06 	sts	0x0602, r24
	while(1)
	{
		//send_char(0x01);
		//_delay_ms(2000);
		
		if((PORTA_IN & 0x01)==0x00)//checking for sw1
 546:	c8 e0       	ldi	r28, 0x08	; 8
 548:	d6 e0       	ldi	r29, 0x06	; 6
	gfx_mono_init();
	PORTA_DIRCLR=0x01;
//	PORTE_OUTSET=(1<<4);

	again:
	gfx_mono_draw_string(" welcome ",0, 0, &sysfont);
 54a:	2a e2       	ldi	r18, 0x2A	; 42
 54c:	30 e2       	ldi	r19, 0x20	; 32
 54e:	40 e0       	ldi	r20, 0x00	; 0
 550:	60 e0       	ldi	r22, 0x00	; 0
 552:	81 e3       	ldi	r24, 0x31	; 49
 554:	90 e2       	ldi	r25, 0x20	; 32
 556:	90 d3       	rcall	.+1824   	; 0xc78 <gfx_mono_draw_string>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 558:	2f ef       	ldi	r18, 0xFF	; 255
 55a:	31 ee       	ldi	r19, 0xE1	; 225
 55c:	84 e0       	ldi	r24, 0x04	; 4
 55e:	21 50       	subi	r18, 0x01	; 1
 560:	30 40       	sbci	r19, 0x00	; 0
 562:	80 40       	sbci	r24, 0x00	; 0
 564:	e1 f7       	brne	.-8      	; 0x55e <main+0x2a>
 566:	00 c0       	rjmp	.+0      	; 0x568 <main+0x34>
 568:	00 00       	nop
	_delay_ms(50);
	//LCD_cmd(0x01);
	//LCD_cmd(0xc0);
	gfx_mono_draw_string("SCAN YOUR FINGER",0, 0, &sysfont);
 56a:	2a e2       	ldi	r18, 0x2A	; 42
 56c:	30 e2       	ldi	r19, 0x20	; 32
 56e:	40 e0       	ldi	r20, 0x00	; 0
 570:	60 e0       	ldi	r22, 0x00	; 0
 572:	8b e3       	ldi	r24, 0x3B	; 59
 574:	90 e2       	ldi	r25, 0x20	; 32
 576:	80 d3       	rcall	.+1792   	; 0xc78 <gfx_mono_draw_string>
 578:	9f ef       	ldi	r25, 0xFF	; 255
 57a:	21 ee       	ldi	r18, 0xE1	; 225
 57c:	34 e0       	ldi	r19, 0x04	; 4
 57e:	91 50       	subi	r25, 0x01	; 1
 580:	20 40       	sbci	r18, 0x00	; 0
 582:	30 40       	sbci	r19, 0x00	; 0
 584:	e1 f7       	brne	.-8      	; 0x57e <main+0x4a>
 586:	00 c0       	rjmp	.+0      	; 0x588 <main+0x54>
 588:	00 00       	nop
	_delay_ms(50);
	i=0;
 58a:	10 92 e8 20 	sts	0x20E8, r1
	while(1)
	{
		//send_char(0x01);
		//_delay_ms(2000);
		
		if((PORTA_IN & 0x01)==0x00)//checking for sw1
 58e:	88 81       	ld	r24, Y
 590:	80 fd       	sbrc	r24, 0
 592:	74 c0       	rjmp	.+232    	; 0x67c <main+0x148>
		{
			//PORTA_OUTSET=0x01;
		    while((PORTA_IN & 0x01)==0x00);
 594:	88 81       	ld	r24, Y
 596:	80 ff       	sbrs	r24, 0
 598:	fd cf       	rjmp	.-6      	; 0x594 <main+0x60>
			//LCD_cmd(0x01);
			gfx_mono_init();
 59a:	ec d1       	rcall	.+984    	; 0x974 <gfx_mono_st7565r_init>
			gfx_mono_draw_string("scanning new image",0, 0, &sysfont);
 59c:	2a e2       	ldi	r18, 0x2A	; 42
 59e:	30 e2       	ldi	r19, 0x20	; 32
 5a0:	40 e0       	ldi	r20, 0x00	; 0
 5a2:	60 e0       	ldi	r22, 0x00	; 0
 5a4:	8c e4       	ldi	r24, 0x4C	; 76
 5a6:	90 e2       	ldi	r25, 0x20	; 32
 5a8:	67 d3       	rcall	.+1742   	; 0xc78 <gfx_mono_draw_string>
 5aa:	8a ea       	ldi	r24, 0xAA	; 170
 5ac:	96 ee       	ldi	r25, 0xE6	; 230
 5ae:	26 e9       	ldi	r18, 0x96	; 150
 5b0:	31 e0       	ldi	r19, 0x01	; 1
 5b2:	81 50       	subi	r24, 0x01	; 1
 5b4:	90 40       	sbci	r25, 0x00	; 0
 5b6:	20 40       	sbci	r18, 0x00	; 0
 5b8:	30 40       	sbci	r19, 0x00	; 0
 5ba:	d9 f7       	brne	.-10     	; 0x5b2 <main+0x7e>
 5bc:	00 00       	nop
			//_delay_ms(1000);
			//send_char(0x01);
			_delay_ms(5000);
			
			i=0;
 5be:	10 92 e8 20 	sts	0x20E8, r1
			while(i<12)
 5c2:	e0 e0       	ldi	r30, 0x00	; 0
			{
				send_char(enroll[i]);
 5c4:	f0 e0       	ldi	r31, 0x00	; 0
 5c6:	e2 5e       	subi	r30, 0xE2	; 226
 5c8:	ff 4d       	sbci	r31, 0xDF	; 223
 5ca:	80 81       	ld	r24, Z
 5cc:	a3 df       	rcall	.-186    	; 0x514 <send_char>
				i++;
 5ce:	e0 91 e8 20 	lds	r30, 0x20E8
 5d2:	ef 5f       	subi	r30, 0xFF	; 255
 5d4:	e0 93 e8 20 	sts	0x20E8, r30
			//_delay_ms(1000);
			//send_char(0x01);
			_delay_ms(5000);
			
			i=0;
			while(i<12)
 5d8:	ec 30       	cpi	r30, 0x0C	; 12
 5da:	a0 f3       	brcs	.-24     	; 0x5c4 <main+0x90>
			}
			//gfx_mono_init();
		    //gfx_mono_draw_string("Command sent....",0, 0, &sysfont);
			//_delay_ms(50);
		
			rec=receive_data();
 5dc:	a3 df       	rcall	.-186    	; 0x524 <receive_data>
 5de:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 5e2:	a0 df       	rcall	.-192    	; 0x524 <receive_data>
 5e4:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 5e8:	9d df       	rcall	.-198    	; 0x524 <receive_data>
 5ea:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 5ee:	9a df       	rcall	.-204    	; 0x524 <receive_data>
 5f0:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 5f4:	97 df       	rcall	.-210    	; 0x524 <receive_data>
 5f6:	80 93 05 23 	sts	0x2305, r24
			//gfx_mono_draw_string("Receiving data....",0, 0, &sysfont);
			rec=receive_data();
 5fa:	94 df       	rcall	.-216    	; 0x524 <receive_data>
 5fc:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 600:	91 df       	rcall	.-222    	; 0x524 <receive_data>
 602:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 606:	8e df       	rcall	.-228    	; 0x524 <receive_data>
 608:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 60c:	8b df       	rcall	.-234    	; 0x524 <receive_data>
 60e:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 612:	88 df       	rcall	.-240    	; 0x524 <receive_data>
 614:	80 93 05 23 	sts	0x2305, r24
			dummy=receive_data();
 618:	85 df       	rcall	.-246    	; 0x524 <receive_data>
 61a:	80 93 00 23 	sts	0x2300, r24
			dummy=receive_data();
 61e:	82 df       	rcall	.-252    	; 0x524 <receive_data>
 620:	80 93 00 23 	sts	0x2300, r24
			if(!rec)//{LCD_cmd(0x01);
 624:	80 91 05 23 	lds	r24, 0x2305
 628:	81 11       	cpse	r24, r1
 62a:	16 c0       	rjmp	.+44     	; 0x658 <main+0x124>
			{
				gfx_mono_init();
 62c:	a3 d1       	rcall	.+838    	; 0x974 <gfx_mono_st7565r_init>
				gfx_mono_draw_string("Enrolling ok",0, 0, &sysfont);
 62e:	2a e2       	ldi	r18, 0x2A	; 42
 630:	30 e2       	ldi	r19, 0x20	; 32
 632:	40 e0       	ldi	r20, 0x00	; 0
 634:	60 e0       	ldi	r22, 0x00	; 0
 636:	8f e5       	ldi	r24, 0x5F	; 95
 638:	90 e2       	ldi	r25, 0x20	; 32
 63a:	1e d3       	rcall	.+1596   	; 0xc78 <gfx_mono_draw_string>
 63c:	8a ea       	ldi	r24, 0xAA	; 170
 63e:	96 ee       	ldi	r25, 0xE6	; 230
 640:	26 e9       	ldi	r18, 0x96	; 150
 642:	31 e0       	ldi	r19, 0x01	; 1
 644:	81 50       	subi	r24, 0x01	; 1
 646:	90 40       	sbci	r25, 0x00	; 0
 648:	20 40       	sbci	r18, 0x00	; 0
 64a:	30 40       	sbci	r19, 0x00	; 0
 64c:	d9 f7       	brne	.-10     	; 0x644 <main+0x110>
 64e:	00 00       	nop
				gfx_mono_draw_string("2: Enrolling not ok",0, 0, &sysfont);
				_delay_ms(2000);
				goto again;
		}

			i=0;
 650:	10 92 e8 20 	sts	0x20E8, r1
			while(i<13)
 654:	e0 e0       	ldi	r30, 0x00	; 0
 656:	24 c0       	rjmp	.+72     	; 0x6a0 <main+0x16c>
				gfx_mono_draw_string("Enrolling ok",0, 0, &sysfont);
				_delay_ms(5000);
			}
			else
			{
				gfx_mono_init();
 658:	8d d1       	rcall	.+794    	; 0x974 <gfx_mono_st7565r_init>
				//LCD_cmd(0x01);
				gfx_mono_draw_string("1: Enrolling not ok",0, 0, &sysfont);
 65a:	2a e2       	ldi	r18, 0x2A	; 42
 65c:	30 e2       	ldi	r19, 0x20	; 32
 65e:	40 e0       	ldi	r20, 0x00	; 0
 660:	60 e0       	ldi	r22, 0x00	; 0
 662:	8c e6       	ldi	r24, 0x6C	; 108
 664:	90 e2       	ldi	r25, 0x20	; 32
 666:	08 d3       	rcall	.+1552   	; 0xc78 <gfx_mono_draw_string>
 668:	8f ef       	ldi	r24, 0xFF	; 255
 66a:	9f e4       	ldi	r25, 0x4F	; 79
 66c:	23 ec       	ldi	r18, 0xC3	; 195
 66e:	81 50       	subi	r24, 0x01	; 1
 670:	90 40       	sbci	r25, 0x00	; 0
 672:	20 40       	sbci	r18, 0x00	; 0
 674:	e1 f7       	brne	.-8      	; 0x66e <main+0x13a>
 676:	00 c0       	rjmp	.+0      	; 0x678 <main+0x144>
 678:	00 00       	nop
 67a:	67 cf       	rjmp	.-306    	; 0x54a <main+0x16>
				goto again;
			}
		}
		else
		{
				gfx_mono_init();
 67c:	7b d1       	rcall	.+758    	; 0x974 <gfx_mono_st7565r_init>
				//LCD_cmd(0x01);
				gfx_mono_draw_string("2: Enrolling not ok",0, 0, &sysfont);
 67e:	2a e2       	ldi	r18, 0x2A	; 42
 680:	30 e2       	ldi	r19, 0x20	; 32
 682:	40 e0       	ldi	r20, 0x00	; 0
 684:	60 e0       	ldi	r22, 0x00	; 0
 686:	80 e8       	ldi	r24, 0x80	; 128
 688:	90 e2       	ldi	r25, 0x20	; 32
 68a:	f6 d2       	rcall	.+1516   	; 0xc78 <gfx_mono_draw_string>
 68c:	3f ef       	ldi	r19, 0xFF	; 255
 68e:	8f e4       	ldi	r24, 0x4F	; 79
 690:	93 ec       	ldi	r25, 0xC3	; 195
 692:	31 50       	subi	r19, 0x01	; 1
 694:	80 40       	sbci	r24, 0x00	; 0
 696:	90 40       	sbci	r25, 0x00	; 0
 698:	e1 f7       	brne	.-8      	; 0x692 <main+0x15e>
 69a:	00 c0       	rjmp	.+0      	; 0x69c <main+0x168>
 69c:	00 00       	nop
 69e:	55 cf       	rjmp	.-342    	; 0x54a <main+0x16>
		}

			i=0;
			while(i<13)
			{
				send_char(generate_ch[i]);
 6a0:	f0 e0       	ldi	r31, 0x00	; 0
 6a2:	ef 5e       	subi	r30, 0xEF	; 239
 6a4:	ff 4d       	sbci	r31, 0xDF	; 223
 6a6:	80 81       	ld	r24, Z
 6a8:	35 df       	rcall	.-406    	; 0x514 <send_char>
				i++;
 6aa:	e0 91 e8 20 	lds	r30, 0x20E8
 6ae:	ef 5f       	subi	r30, 0xFF	; 255
 6b0:	e0 93 e8 20 	sts	0x20E8, r30
				_delay_ms(2000);
				goto again;
		}

			i=0;
			while(i<13)
 6b4:	ed 30       	cpi	r30, 0x0D	; 13
 6b6:	a0 f3       	brcs	.-24     	; 0x6a0 <main+0x16c>
			{
				send_char(generate_ch[i]);
				i++;
			}
			//_delay_ms(1);
			rec=receive_data();
 6b8:	35 df       	rcall	.-406    	; 0x524 <receive_data>
 6ba:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6be:	32 df       	rcall	.-412    	; 0x524 <receive_data>
 6c0:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6c4:	2f df       	rcall	.-418    	; 0x524 <receive_data>
 6c6:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6ca:	2c df       	rcall	.-424    	; 0x524 <receive_data>
 6cc:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6d0:	29 df       	rcall	.-430    	; 0x524 <receive_data>
 6d2:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6d6:	26 df       	rcall	.-436    	; 0x524 <receive_data>
 6d8:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6dc:	23 df       	rcall	.-442    	; 0x524 <receive_data>
 6de:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6e2:	20 df       	rcall	.-448    	; 0x524 <receive_data>
 6e4:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6e8:	1d df       	rcall	.-454    	; 0x524 <receive_data>
 6ea:	80 93 05 23 	sts	0x2305, r24
			rec=receive_data();
 6ee:	1a df       	rcall	.-460    	; 0x524 <receive_data>
 6f0:	80 93 05 23 	sts	0x2305, r24
			dummy=receive_data();
 6f4:	17 df       	rcall	.-466    	; 0x524 <receive_data>
 6f6:	80 93 00 23 	sts	0x2300, r24
			dummy=receive_data();
 6fa:	14 df       	rcall	.-472    	; 0x524 <receive_data>
 6fc:	80 93 00 23 	sts	0x2300, r24
			if(!rec)
 700:	80 91 05 23 	lds	r24, 0x2305
 704:	81 11       	cpse	r24, r1
 706:	8d c0       	rjmp	.+282    	; 0x822 <main+0x2ee>
			{
				//gfx_mono_init();
				//LCD_cmd(0x01);
				gfx_mono_init();
 708:	35 d1       	rcall	.+618    	; 0x974 <gfx_mono_st7565r_init>
				gfx_mono_draw_string("genchar  ok",0, 0, &sysfont);
 70a:	2a e2       	ldi	r18, 0x2A	; 42
 70c:	30 e2       	ldi	r19, 0x20	; 32
 70e:	40 e0       	ldi	r20, 0x00	; 0
 710:	60 e0       	ldi	r22, 0x00	; 0
 712:	84 e9       	ldi	r24, 0x94	; 148
 714:	90 e2       	ldi	r25, 0x20	; 32
 716:	b0 d2       	rcall	.+1376   	; 0xc78 <gfx_mono_draw_string>
 718:	2f ef       	ldi	r18, 0xFF	; 255
 71a:	3f e4       	ldi	r19, 0x4F	; 79
 71c:	83 ec       	ldi	r24, 0xC3	; 195
 71e:	21 50       	subi	r18, 0x01	; 1
 720:	30 40       	sbci	r19, 0x00	; 0
 722:	80 40       	sbci	r24, 0x00	; 0
 724:	e1 f7       	brne	.-8      	; 0x71e <main+0x1ea>
 726:	00 c0       	rjmp	.+0      	; 0x728 <main+0x1f4>
 728:	00 00       	nop
				_delay_ms(2000);
				
				//gfx_mono_init();
				gfx_mono_draw_string("Entering to Identify",0, 0, &sysfont);
 72a:	2a e2       	ldi	r18, 0x2A	; 42
 72c:	30 e2       	ldi	r19, 0x20	; 32
 72e:	40 e0       	ldi	r20, 0x00	; 0
 730:	60 e0       	ldi	r22, 0x00	; 0
 732:	80 ea       	ldi	r24, 0xA0	; 160
 734:	90 e2       	ldi	r25, 0x20	; 32
 736:	a0 d2       	rcall	.+1344   	; 0xc78 <gfx_mono_draw_string>
 738:	9f ef       	ldi	r25, 0xFF	; 255
 73a:	2f e4       	ldi	r18, 0x4F	; 79
 73c:	33 ec       	ldi	r19, 0xC3	; 195
 73e:	91 50       	subi	r25, 0x01	; 1
 740:	20 40       	sbci	r18, 0x00	; 0
 742:	30 40       	sbci	r19, 0x00	; 0
 744:	e1 f7       	brne	.-8      	; 0x73e <main+0x20a>
 746:	00 c0       	rjmp	.+0      	; 0x748 <main+0x214>
 748:	00 00       	nop
				
				//	while((PORTA_IN & 0x04)==0x00);
				//LCD_cmd(0x01);
				//	gfx_mono_draw_string("Identfying...",0, 0, &sysfont);
				//_delay_ms(1000);
				i=0;
 74a:	10 92 e8 20 	sts	0x20E8, r1
				while(i<17)
 74e:	e0 e0       	ldi	r30, 0x00	; 0
				{
					send_char(identify[i]);
 750:	f0 e0       	ldi	r31, 0x00	; 0
 752:	e0 50       	subi	r30, 0x00	; 0
 754:	f0 4e       	sbci	r31, 0xE0	; 224
 756:	80 81       	ld	r24, Z
 758:	dd de       	rcall	.-582    	; 0x514 <send_char>
					i++;
 75a:	e0 91 e8 20 	lds	r30, 0x20E8
 75e:	ef 5f       	subi	r30, 0xFF	; 255
 760:	e0 93 e8 20 	sts	0x20E8, r30
				//	while((PORTA_IN & 0x04)==0x00);
				//LCD_cmd(0x01);
				//	gfx_mono_draw_string("Identfying...",0, 0, &sysfont);
				//_delay_ms(1000);
				i=0;
				while(i<17)
 764:	e1 31       	cpi	r30, 0x11	; 17
 766:	a0 f3       	brcs	.-24     	; 0x750 <main+0x21c>
				{
					send_char(identify[i]);
					i++;
				}
				rec=receive_data();
 768:	dd de       	rcall	.-582    	; 0x524 <receive_data>
 76a:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 76e:	da de       	rcall	.-588    	; 0x524 <receive_data>
 770:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 774:	d7 de       	rcall	.-594    	; 0x524 <receive_data>
 776:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 77a:	d4 de       	rcall	.-600    	; 0x524 <receive_data>
 77c:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 780:	d1 de       	rcall	.-606    	; 0x524 <receive_data>
 782:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 786:	ce de       	rcall	.-612    	; 0x524 <receive_data>
 788:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 78c:	cb de       	rcall	.-618    	; 0x524 <receive_data>
 78e:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 792:	c8 de       	rcall	.-624    	; 0x524 <receive_data>
 794:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 798:	c5 de       	rcall	.-630    	; 0x524 <receive_data>
 79a:	80 93 05 23 	sts	0x2305, r24
				rec=receive_data();
 79e:	c2 de       	rcall	.-636    	; 0x524 <receive_data>
 7a0:	80 93 05 23 	sts	0x2305, r24
				dummy=receive_data();
 7a4:	bf de       	rcall	.-642    	; 0x524 <receive_data>
 7a6:	80 93 00 23 	sts	0x2300, r24
				dummy=receive_data();
 7aa:	bc de       	rcall	.-648    	; 0x524 <receive_data>
 7ac:	80 93 00 23 	sts	0x2300, r24
				dummy=receive_data();
 7b0:	b9 de       	rcall	.-654    	; 0x524 <receive_data>
 7b2:	80 93 00 23 	sts	0x2300, r24
				dummy=receive_data();
 7b6:	b6 de       	rcall	.-660    	; 0x524 <receive_data>
 7b8:	80 93 00 23 	sts	0x2300, r24
				dummy=receive_data();
 7bc:	b3 de       	rcall	.-666    	; 0x524 <receive_data>
 7be:	80 93 00 23 	sts	0x2300, r24
				dummy=receive_data();
 7c2:	b0 de       	rcall	.-672    	; 0x524 <receive_data>
 7c4:	80 93 00 23 	sts	0x2300, r24
				if(!rec)
 7c8:	80 91 05 23 	lds	r24, 0x2305
 7cc:	81 11       	cpse	r24, r1
 7ce:	16 c0       	rjmp	.+44     	; 0x7fc <main+0x2c8>
				{
					//LCD_cmd(0x01);
					//				gfx_mono_draw_string("store ok",0, 0, &sysfont);
					gfx_mono_init();
 7d0:	d1 d0       	rcall	.+418    	; 0x974 <gfx_mono_st7565r_init>
					gfx_mono_draw_string("Matched: Open the door",0, 0, &sysfont);
 7d2:	2a e2       	ldi	r18, 0x2A	; 42
 7d4:	30 e2       	ldi	r19, 0x20	; 32
 7d6:	40 e0       	ldi	r20, 0x00	; 0
 7d8:	60 e0       	ldi	r22, 0x00	; 0
 7da:	85 eb       	ldi	r24, 0xB5	; 181
 7dc:	90 e2       	ldi	r25, 0x20	; 32
 7de:	4c d2       	rcall	.+1176   	; 0xc78 <gfx_mono_draw_string>
 7e0:	8a ea       	ldi	r24, 0xAA	; 170
 7e2:	96 ee       	ldi	r25, 0xE6	; 230
 7e4:	26 e9       	ldi	r18, 0x96	; 150
 7e6:	31 e0       	ldi	r19, 0x01	; 1
 7e8:	81 50       	subi	r24, 0x01	; 1
 7ea:	90 40       	sbci	r25, 0x00	; 0
 7ec:	20 40       	sbci	r18, 0x00	; 0
 7ee:	30 40       	sbci	r19, 0x00	; 0
 7f0:	d9 f7       	brne	.-10     	; 0x7e8 <main+0x2b4>
 7f2:	00 00       	nop
	while(1)
	{
		//send_char(0x01);
		//_delay_ms(2000);
		
		if((PORTA_IN & 0x01)==0x00)//checking for sw1
 7f4:	88 81       	ld	r24, Y
 7f6:	80 ff       	sbrs	r24, 0
 7f8:	cd ce       	rjmp	.-614    	; 0x594 <main+0x60>
 7fa:	40 cf       	rjmp	.-384    	; 0x67c <main+0x148>
				}
				else
				{
					//gfx_mono_init();
					//LCD_cmd(0x01);
					gfx_mono_init();
 7fc:	bb d0       	rcall	.+374    	; 0x974 <gfx_mono_st7565r_init>
					gfx_mono_draw_string("Not Matched",0, 0, &sysfont);
 7fe:	2a e2       	ldi	r18, 0x2A	; 42
 800:	30 e2       	ldi	r19, 0x20	; 32
 802:	40 e0       	ldi	r20, 0x00	; 0
 804:	60 e0       	ldi	r22, 0x00	; 0
 806:	8c ec       	ldi	r24, 0xCC	; 204
 808:	90 e2       	ldi	r25, 0x20	; 32
 80a:	36 d2       	rcall	.+1132   	; 0xc78 <gfx_mono_draw_string>
 80c:	8a ea       	ldi	r24, 0xAA	; 170
 80e:	96 ee       	ldi	r25, 0xE6	; 230
 810:	26 e9       	ldi	r18, 0x96	; 150
 812:	31 e0       	ldi	r19, 0x01	; 1
 814:	81 50       	subi	r24, 0x01	; 1
 816:	90 40       	sbci	r25, 0x00	; 0
 818:	20 40       	sbci	r18, 0x00	; 0
 81a:	30 40       	sbci	r19, 0x00	; 0
 81c:	d9 f7       	brne	.-10     	; 0x814 <main+0x2e0>
 81e:	00 00       	nop
 820:	94 ce       	rjmp	.-728    	; 0x54a <main+0x16>
				}
			}
			else
			{
				//LCD_cmd(0x01);
				gfx_mono_init();
 822:	a8 d0       	rcall	.+336    	; 0x974 <gfx_mono_st7565r_init>
				gfx_mono_draw_string("genchar not ok",0, 0, &sysfont);
 824:	2a e2       	ldi	r18, 0x2A	; 42
 826:	30 e2       	ldi	r19, 0x20	; 32
 828:	40 e0       	ldi	r20, 0x00	; 0
 82a:	60 e0       	ldi	r22, 0x00	; 0
 82c:	88 ed       	ldi	r24, 0xD8	; 216
 82e:	90 e2       	ldi	r25, 0x20	; 32
 830:	23 d2       	rcall	.+1094   	; 0xc78 <gfx_mono_draw_string>
				gfx_mono_draw_char(rec,9,18, &sysfont);
 832:	2a e2       	ldi	r18, 0x2A	; 42
 834:	30 e2       	ldi	r19, 0x20	; 32
 836:	42 e1       	ldi	r20, 0x12	; 18
 838:	69 e0       	ldi	r22, 0x09	; 9
 83a:	80 91 05 23 	lds	r24, 0x2305
 83e:	bf d1       	rcall	.+894    	; 0xbbe <gfx_mono_draw_char>
 840:	8f ef       	ldi	r24, 0xFF	; 255
 842:	93 e2       	ldi	r25, 0x23	; 35
 844:	24 ef       	ldi	r18, 0xF4	; 244
 846:	30 e0       	ldi	r19, 0x00	; 0
 848:	81 50       	subi	r24, 0x01	; 1
 84a:	90 40       	sbci	r25, 0x00	; 0
 84c:	20 40       	sbci	r18, 0x00	; 0
 84e:	30 40       	sbci	r19, 0x00	; 0
 850:	d9 f7       	brne	.-10     	; 0x848 <main+0x314>
 852:	00 c0       	rjmp	.+0      	; 0x854 <main+0x320>
 854:	00 00       	nop
 856:	79 ce       	rjmp	.-782    	; 0x54a <main+0x16>

00000858 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
 858:	1f 93       	push	r17
 85a:	cf 93       	push	r28
 85c:	df 93       	push	r29
 85e:	18 2f       	mov	r17, r24
 860:	d6 2f       	mov	r29, r22
 862:	c4 2f       	mov	r28, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
 864:	03 d1       	rcall	.+518    	; 0xa6c <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
 866:	1f 70       	andi	r17, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
 868:	10 6b       	ori	r17, 0xB0	; 176
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 86a:	88 e0       	ldi	r24, 0x08	; 8
 86c:	e0 ea       	ldi	r30, 0xA0	; 160
 86e:	f6 e0       	ldi	r31, 0x06	; 6
 870:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 872:	81 e0       	ldi	r24, 0x01	; 1
 874:	e0 e6       	ldi	r30, 0x60	; 96
 876:	f6 e0       	ldi	r31, 0x06	; 6
 878:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 87a:	e0 ea       	ldi	r30, 0xA0	; 160
 87c:	f9 e0       	ldi	r31, 0x09	; 9
 87e:	91 81       	ldd	r25, Z+1	; 0x01
 880:	95 ff       	sbrs	r25, 5
 882:	fd cf       	rjmp	.-6      	; 0x87e <gfx_mono_st7565r_put_byte+0x26>
	ST7565R_USART_SPI.DATA = command;
 884:	10 93 a0 09 	sts	0x09A0, r17
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 888:	e0 ea       	ldi	r30, 0xA0	; 160
 88a:	f9 e0       	ldi	r31, 0x09	; 9
 88c:	81 81       	ldd	r24, Z+1	; 0x01
 88e:	86 ff       	sbrs	r24, 6
 890:	fd cf       	rjmp	.-6      	; 0x88c <gfx_mono_st7565r_put_byte+0x34>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 892:	e0 ea       	ldi	r30, 0xA0	; 160
 894:	f9 e0       	ldi	r31, 0x09	; 9
 896:	81 81       	ldd	r24, Z+1	; 0x01
 898:	80 64       	ori	r24, 0x40	; 64
 89a:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 89c:	80 81       	ld	r24, Z
 89e:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 8a2:	e0 ea       	ldi	r30, 0xA0	; 160
 8a4:	f6 e0       	ldi	r31, 0x06	; 6
 8a6:	88 e0       	ldi	r24, 0x08	; 8
 8a8:	85 83       	std	Z+5, r24	; 0x05
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
 8aa:	9d 2f       	mov	r25, r29
 8ac:	9f 77       	andi	r25, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
 8ae:	92 95       	swap	r25
 8b0:	9f 70       	andi	r25, 0x0F	; 15
 8b2:	90 61       	ori	r25, 0x10	; 16
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 8b4:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 8b6:	81 e0       	ldi	r24, 0x01	; 1
 8b8:	e0 e6       	ldi	r30, 0x60	; 96
 8ba:	f6 e0       	ldi	r31, 0x06	; 6
 8bc:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 8be:	e0 ea       	ldi	r30, 0xA0	; 160
 8c0:	f9 e0       	ldi	r31, 0x09	; 9
 8c2:	81 81       	ldd	r24, Z+1	; 0x01
 8c4:	85 ff       	sbrs	r24, 5
 8c6:	fd cf       	rjmp	.-6      	; 0x8c2 <gfx_mono_st7565r_put_byte+0x6a>
	ST7565R_USART_SPI.DATA = command;
 8c8:	90 93 a0 09 	sts	0x09A0, r25
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 8cc:	e0 ea       	ldi	r30, 0xA0	; 160
 8ce:	f9 e0       	ldi	r31, 0x09	; 9
 8d0:	81 81       	ldd	r24, Z+1	; 0x01
 8d2:	86 ff       	sbrs	r24, 6
 8d4:	fd cf       	rjmp	.-6      	; 0x8d0 <gfx_mono_st7565r_put_byte+0x78>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 8d6:	e0 ea       	ldi	r30, 0xA0	; 160
 8d8:	f9 e0       	ldi	r31, 0x09	; 9
 8da:	81 81       	ldd	r24, Z+1	; 0x01
 8dc:	80 64       	ori	r24, 0x40	; 64
 8de:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 8e0:	80 81       	ld	r24, Z
 8e2:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 8e6:	e0 ea       	ldi	r30, 0xA0	; 160
 8e8:	f6 e0       	ldi	r31, 0x06	; 6
 8ea:	88 e0       	ldi	r24, 0x08	; 8
 8ec:	85 83       	std	Z+5, r24	; 0x05
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
 8ee:	df 70       	andi	r29, 0x0F	; 15
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 8f0:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 8f2:	81 e0       	ldi	r24, 0x01	; 1
 8f4:	e0 e6       	ldi	r30, 0x60	; 96
 8f6:	f6 e0       	ldi	r31, 0x06	; 6
 8f8:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 8fa:	e0 ea       	ldi	r30, 0xA0	; 160
 8fc:	f9 e0       	ldi	r31, 0x09	; 9
 8fe:	81 81       	ldd	r24, Z+1	; 0x01
 900:	85 ff       	sbrs	r24, 5
 902:	fd cf       	rjmp	.-6      	; 0x8fe <gfx_mono_st7565r_put_byte+0xa6>
	ST7565R_USART_SPI.DATA = command;
 904:	d0 93 a0 09 	sts	0x09A0, r29
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 908:	e0 ea       	ldi	r30, 0xA0	; 160
 90a:	f9 e0       	ldi	r31, 0x09	; 9
 90c:	81 81       	ldd	r24, Z+1	; 0x01
 90e:	86 ff       	sbrs	r24, 6
 910:	fd cf       	rjmp	.-6      	; 0x90c <gfx_mono_st7565r_put_byte+0xb4>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 912:	e0 ea       	ldi	r30, 0xA0	; 160
 914:	f9 e0       	ldi	r31, 0x09	; 9
 916:	81 81       	ldd	r24, Z+1	; 0x01
 918:	80 64       	ori	r24, 0x40	; 64
 91a:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 91c:	80 81       	ld	r24, Z
 91e:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 922:	e0 ea       	ldi	r30, 0xA0	; 160
 924:	f6 e0       	ldi	r31, 0x06	; 6
 926:	88 e0       	ldi	r24, 0x08	; 8
 928:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 92a:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTSET = ST7565R_A0_PIN;
 92c:	81 e0       	ldi	r24, 0x01	; 1
 92e:	e0 e6       	ldi	r30, 0x60	; 96
 930:	f6 e0       	ldi	r31, 0x06	; 6
 932:	85 83       	std	Z+5, r24	; 0x05
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 934:	e0 ea       	ldi	r30, 0xA0	; 160
 936:	f9 e0       	ldi	r31, 0x09	; 9
 938:	81 81       	ldd	r24, Z+1	; 0x01
 93a:	85 ff       	sbrs	r24, 5
 93c:	fd cf       	rjmp	.-6      	; 0x938 <gfx_mono_st7565r_put_byte+0xe0>
	ST7565R_USART_SPI.DATA = data;
 93e:	c0 93 a0 09 	sts	0x09A0, r28
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 942:	e0 ea       	ldi	r30, 0xA0	; 160
 944:	f9 e0       	ldi	r31, 0x09	; 9
 946:	81 81       	ldd	r24, Z+1	; 0x01
 948:	86 ff       	sbrs	r24, 6
 94a:	fd cf       	rjmp	.-6      	; 0x946 <gfx_mono_st7565r_put_byte+0xee>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 94c:	e0 ea       	ldi	r30, 0xA0	; 160
 94e:	f9 e0       	ldi	r31, 0x09	; 9
 950:	81 81       	ldd	r24, Z+1	; 0x01
 952:	80 64       	ori	r24, 0x40	; 64
 954:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 956:	80 81       	ld	r24, Z
 958:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 95c:	81 e0       	ldi	r24, 0x01	; 1
 95e:	e0 e6       	ldi	r30, 0x60	; 96
 960:	f6 e0       	ldi	r31, 0x06	; 6
 962:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 964:	88 e0       	ldi	r24, 0x08	; 8
 966:	e0 ea       	ldi	r30, 0xA0	; 160
 968:	f6 e0       	ldi	r31, 0x06	; 6
 96a:	85 83       	std	Z+5, r24	; 0x05

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
 96c:	df 91       	pop	r29
 96e:	cf 91       	pop	r28
 970:	1f 91       	pop	r17
 972:	08 95       	ret

00000974 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
 974:	cf 93       	push	r28
 976:	df 93       	push	r29
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
 978:	89 ee       	ldi	r24, 0xE9	; 233
 97a:	90 e2       	ldi	r25, 0x20	; 32
 97c:	72 d0       	rcall	.+228    	; 0xa62 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
 97e:	a5 d1       	rcall	.+842    	; 0xcca <st7565r_init>
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 980:	88 e0       	ldi	r24, 0x08	; 8
 982:	e0 ea       	ldi	r30, 0xA0	; 160
 984:	f6 e0       	ldi	r31, 0x06	; 6
 986:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 988:	81 e0       	ldi	r24, 0x01	; 1
 98a:	e0 e6       	ldi	r30, 0x60	; 96
 98c:	f6 e0       	ldi	r31, 0x06	; 6
 98e:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 990:	e0 ea       	ldi	r30, 0xA0	; 160
 992:	f9 e0       	ldi	r31, 0x09	; 9
 994:	81 81       	ldd	r24, Z+1	; 0x01
 996:	85 ff       	sbrs	r24, 5
 998:	fd cf       	rjmp	.-6      	; 0x994 <gfx_mono_st7565r_init+0x20>
	ST7565R_USART_SPI.DATA = command;
 99a:	80 e4       	ldi	r24, 0x40	; 64
 99c:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 9a0:	e0 ea       	ldi	r30, 0xA0	; 160
 9a2:	f9 e0       	ldi	r31, 0x09	; 9
 9a4:	81 81       	ldd	r24, Z+1	; 0x01
 9a6:	86 ff       	sbrs	r24, 6
 9a8:	fd cf       	rjmp	.-6      	; 0x9a4 <gfx_mono_st7565r_init+0x30>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 9aa:	e0 ea       	ldi	r30, 0xA0	; 160
 9ac:	f9 e0       	ldi	r31, 0x09	; 9
 9ae:	81 81       	ldd	r24, Z+1	; 0x01
 9b0:	80 64       	ori	r24, 0x40	; 64
 9b2:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 9b4:	80 81       	ld	r24, Z
 9b6:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 9ba:	88 e0       	ldi	r24, 0x08	; 8
 9bc:	e0 ea       	ldi	r30, 0xA0	; 160
 9be:	f6 e0       	ldi	r31, 0x06	; 6
 9c0:	85 83       	std	Z+5, r24	; 0x05

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
 9c2:	d0 e0       	ldi	r29, 0x00	; 0
 9c4:	0a c0       	rjmp	.+20     	; 0x9da <gfx_mono_st7565r_init+0x66>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
 9c6:	40 e0       	ldi	r20, 0x00	; 0
 9c8:	6c 2f       	mov	r22, r28
 9ca:	8d 2f       	mov	r24, r29
 9cc:	45 df       	rcall	.-374    	; 0x858 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
 9ce:	cf 5f       	subi	r28, 0xFF	; 255
 9d0:	c0 38       	cpi	r28, 0x80	; 128
 9d2:	c9 f7       	brne	.-14     	; 0x9c6 <gfx_mono_st7565r_init+0x52>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
 9d4:	df 5f       	subi	r29, 0xFF	; 255
 9d6:	d4 30       	cpi	r29, 0x04	; 4
 9d8:	11 f0       	breq	.+4      	; 0x9de <gfx_mono_st7565r_init+0x6a>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
 9da:	c0 e0       	ldi	r28, 0x00	; 0
 9dc:	f4 cf       	rjmp	.-24     	; 0x9c6 <gfx_mono_st7565r_init+0x52>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
 9de:	df 91       	pop	r29
 9e0:	cf 91       	pop	r28
 9e2:	08 95       	ret

000009e4 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
 9e4:	ff 92       	push	r15
 9e6:	0f 93       	push	r16
 9e8:	1f 93       	push	r17
 9ea:	cf 93       	push	r28
 9ec:	df 93       	push	r29
 9ee:	18 2f       	mov	r17, r24
 9f0:	04 2f       	mov	r16, r20
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
 9f2:	88 23       	and	r24, r24
 9f4:	74 f1       	brlt	.+92     	; 0xa52 <gfx_mono_st7565r_draw_pixel+0x6e>
 9f6:	60 32       	cpi	r22, 0x20	; 32
 9f8:	60 f5       	brcc	.+88     	; 0xa52 <gfx_mono_st7565r_draw_pixel+0x6e>
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
 9fa:	f6 2e       	mov	r15, r22
 9fc:	f6 94       	lsr	r15
 9fe:	f6 94       	lsr	r15
 a00:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
 a02:	2f 2d       	mov	r18, r15
 a04:	30 e0       	ldi	r19, 0x00	; 0
 a06:	31 95       	neg	r19
 a08:	21 95       	neg	r18
 a0a:	31 09       	sbc	r19, r1
 a0c:	22 0f       	add	r18, r18
 a0e:	33 1f       	adc	r19, r19
 a10:	22 0f       	add	r18, r18
 a12:	33 1f       	adc	r19, r19
 a14:	22 0f       	add	r18, r18
 a16:	33 1f       	adc	r19, r19
 a18:	26 0f       	add	r18, r22
 a1a:	31 1d       	adc	r19, r1
 a1c:	e1 e0       	ldi	r30, 0x01	; 1
 a1e:	f0 e0       	ldi	r31, 0x00	; 0
 a20:	ef 01       	movw	r28, r30
 a22:	02 c0       	rjmp	.+4      	; 0xa28 <gfx_mono_st7565r_draw_pixel+0x44>
 a24:	cc 0f       	add	r28, r28
 a26:	dd 1f       	adc	r29, r29
 a28:	2a 95       	dec	r18
 a2a:	e2 f7       	brpl	.-8      	; 0xa24 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
 a2c:	68 2f       	mov	r22, r24
 a2e:	8f 2d       	mov	r24, r15
 a30:	2c d0       	rcall	.+88     	; 0xa8a <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
 a32:	01 30       	cpi	r16, 0x01	; 1
 a34:	21 f0       	breq	.+8      	; 0xa3e <gfx_mono_st7565r_draw_pixel+0x5a>
 a36:	28 f0       	brcs	.+10     	; 0xa42 <gfx_mono_st7565r_draw_pixel+0x5e>
 a38:	02 30       	cpi	r16, 0x02	; 2
 a3a:	31 f0       	breq	.+12     	; 0xa48 <gfx_mono_st7565r_draw_pixel+0x64>
 a3c:	06 c0       	rjmp	.+12     	; 0xa4a <gfx_mono_st7565r_draw_pixel+0x66>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
 a3e:	8c 2b       	or	r24, r28
		break;
 a40:	04 c0       	rjmp	.+8      	; 0xa4a <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
 a42:	c0 95       	com	r28
 a44:	8c 23       	and	r24, r28
		break;
 a46:	01 c0       	rjmp	.+2      	; 0xa4a <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
 a48:	8c 27       	eor	r24, r28

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
 a4a:	48 2f       	mov	r20, r24
 a4c:	61 2f       	mov	r22, r17
 a4e:	8f 2d       	mov	r24, r15
 a50:	03 df       	rcall	.-506    	; 0x858 <gfx_mono_st7565r_put_byte>
}
 a52:	df 91       	pop	r29
 a54:	cf 91       	pop	r28
 a56:	1f 91       	pop	r17
 a58:	0f 91       	pop	r16
 a5a:	ff 90       	pop	r15
 a5c:	08 95       	ret

00000a5e <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
 a5e:	15 c0       	rjmp	.+42     	; 0xa8a <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
 a60:	08 95       	ret

00000a62 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
 a62:	80 93 e9 22 	sts	0x22E9, r24
 a66:	90 93 ea 22 	sts	0x22EA, r25
 a6a:	08 95       	ret

00000a6c <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
 a6c:	20 e8       	ldi	r18, 0x80	; 128
 a6e:	82 9f       	mul	r24, r18
 a70:	c0 01       	movw	r24, r0
 a72:	11 24       	eor	r1, r1
 a74:	fc 01       	movw	r30, r24
 a76:	e6 0f       	add	r30, r22
 a78:	f1 1d       	adc	r31, r1
 a7a:	80 91 e9 22 	lds	r24, 0x22E9
 a7e:	90 91 ea 22 	lds	r25, 0x22EA
 a82:	e8 0f       	add	r30, r24
 a84:	f9 1f       	adc	r31, r25
 a86:	40 83       	st	Z, r20
 a88:	08 95       	ret

00000a8a <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
 a8a:	20 e8       	ldi	r18, 0x80	; 128
 a8c:	82 9f       	mul	r24, r18
 a8e:	c0 01       	movw	r24, r0
 a90:	11 24       	eor	r1, r1
 a92:	fc 01       	movw	r30, r24
 a94:	e6 0f       	add	r30, r22
 a96:	f1 1d       	adc	r31, r1
 a98:	80 91 e9 22 	lds	r24, 0x22E9
 a9c:	90 91 ea 22 	lds	r25, 0x22EA
 aa0:	e8 0f       	add	r30, r24
 aa2:	f9 1f       	adc	r31, r25
}
 aa4:	80 81       	ld	r24, Z
 aa6:	08 95       	ret

00000aa8 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
 aa8:	ff 92       	push	r15
 aaa:	0f 93       	push	r16
 aac:	1f 93       	push	r17
 aae:	cf 93       	push	r28
 ab0:	df 93       	push	r29
 ab2:	e4 2f       	mov	r30, r20
 ab4:	f0 e0       	ldi	r31, 0x00	; 0
 ab6:	e8 0f       	add	r30, r24
 ab8:	f1 1d       	adc	r31, r1
 aba:	e1 38       	cpi	r30, 0x81	; 129
 abc:	f1 05       	cpc	r31, r1
 abe:	14 f0       	brlt	.+4      	; 0xac4 <gfx_mono_generic_draw_horizontal_line+0x1c>
 ac0:	40 e8       	ldi	r20, 0x80	; 128
 ac2:	48 1b       	sub	r20, r24
 ac4:	44 23       	and	r20, r20
 ac6:	09 f4       	brne	.+2      	; 0xaca <gfx_mono_generic_draw_horizontal_line+0x22>
 ac8:	59 c0       	rjmp	.+178    	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0xd4>
 aca:	c6 2f       	mov	r28, r22
 acc:	c6 95       	lsr	r28
 ace:	c6 95       	lsr	r28
 ad0:	c6 95       	lsr	r28
 ad2:	ec 2f       	mov	r30, r28
 ad4:	f0 e0       	ldi	r31, 0x00	; 0
 ad6:	f1 95       	neg	r31
 ad8:	e1 95       	neg	r30
 ada:	f1 09       	sbc	r31, r1
 adc:	ee 0f       	add	r30, r30
 ade:	ff 1f       	adc	r31, r31
 ae0:	ee 0f       	add	r30, r30
 ae2:	ff 1f       	adc	r31, r31
 ae4:	ee 0f       	add	r30, r30
 ae6:	ff 1f       	adc	r31, r31
 ae8:	df 01       	movw	r26, r30
 aea:	a6 0f       	add	r26, r22
 aec:	b1 1d       	adc	r27, r1
 aee:	bd 01       	movw	r22, r26
 af0:	e1 e0       	ldi	r30, 0x01	; 1
 af2:	f0 e0       	ldi	r31, 0x00	; 0
 af4:	df 01       	movw	r26, r30
 af6:	02 c0       	rjmp	.+4      	; 0xafc <gfx_mono_generic_draw_horizontal_line+0x54>
 af8:	aa 0f       	add	r26, r26
 afa:	bb 1f       	adc	r27, r27
 afc:	6a 95       	dec	r22
 afe:	e2 f7       	brpl	.-8      	; 0xaf8 <gfx_mono_generic_draw_horizontal_line+0x50>
 b00:	0a 2f       	mov	r16, r26
 b02:	21 30       	cpi	r18, 0x01	; 1
 b04:	49 f0       	breq	.+18     	; 0xb18 <gfx_mono_generic_draw_horizontal_line+0x70>
 b06:	68 f0       	brcs	.+26     	; 0xb22 <gfx_mono_generic_draw_horizontal_line+0x7a>
 b08:	22 30       	cpi	r18, 0x02	; 2
 b0a:	09 f0       	breq	.+2      	; 0xb0e <gfx_mono_generic_draw_horizontal_line+0x66>
 b0c:	37 c0       	rjmp	.+110    	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0xd4>
 b0e:	d4 2f       	mov	r29, r20
 b10:	ff 24       	eor	r15, r15
 b12:	fa 94       	dec	r15
 b14:	f8 0e       	add	r15, r24
 b16:	26 c0       	rjmp	.+76     	; 0xb64 <gfx_mono_generic_draw_horizontal_line+0xbc>
 b18:	d4 2f       	mov	r29, r20
 b1a:	ff 24       	eor	r15, r15
 b1c:	fa 94       	dec	r15
 b1e:	f8 0e       	add	r15, r24
 b20:	07 c0       	rjmp	.+14     	; 0xb30 <gfx_mono_generic_draw_horizontal_line+0x88>
 b22:	d4 2f       	mov	r29, r20
 b24:	ff 24       	eor	r15, r15
 b26:	fa 94       	dec	r15
 b28:	f8 0e       	add	r15, r24
 b2a:	0a 2f       	mov	r16, r26
 b2c:	00 95       	com	r16
 b2e:	0d c0       	rjmp	.+26     	; 0xb4a <gfx_mono_generic_draw_horizontal_line+0xa2>
 b30:	1f 2d       	mov	r17, r15
 b32:	1d 0f       	add	r17, r29
 b34:	61 2f       	mov	r22, r17
 b36:	8c 2f       	mov	r24, r28
 b38:	92 df       	rcall	.-220    	; 0xa5e <gfx_mono_st7565r_get_byte>
 b3a:	48 2f       	mov	r20, r24
 b3c:	40 2b       	or	r20, r16
 b3e:	61 2f       	mov	r22, r17
 b40:	8c 2f       	mov	r24, r28
 b42:	8a de       	rcall	.-748    	; 0x858 <gfx_mono_st7565r_put_byte>
 b44:	d1 50       	subi	r29, 0x01	; 1
 b46:	a1 f7       	brne	.-24     	; 0xb30 <gfx_mono_generic_draw_horizontal_line+0x88>
 b48:	19 c0       	rjmp	.+50     	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0xd4>
 b4a:	1f 2d       	mov	r17, r15
 b4c:	1d 0f       	add	r17, r29
 b4e:	61 2f       	mov	r22, r17
 b50:	8c 2f       	mov	r24, r28
 b52:	85 df       	rcall	.-246    	; 0xa5e <gfx_mono_st7565r_get_byte>
 b54:	48 2f       	mov	r20, r24
 b56:	40 23       	and	r20, r16
 b58:	61 2f       	mov	r22, r17
 b5a:	8c 2f       	mov	r24, r28
 b5c:	7d de       	rcall	.-774    	; 0x858 <gfx_mono_st7565r_put_byte>
 b5e:	d1 50       	subi	r29, 0x01	; 1
 b60:	a1 f7       	brne	.-24     	; 0xb4a <gfx_mono_generic_draw_horizontal_line+0xa2>
 b62:	0c c0       	rjmp	.+24     	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0xd4>
 b64:	1f 2d       	mov	r17, r15
 b66:	1d 0f       	add	r17, r29
 b68:	61 2f       	mov	r22, r17
 b6a:	8c 2f       	mov	r24, r28
 b6c:	78 df       	rcall	.-272    	; 0xa5e <gfx_mono_st7565r_get_byte>
 b6e:	48 2f       	mov	r20, r24
 b70:	40 27       	eor	r20, r16
 b72:	61 2f       	mov	r22, r17
 b74:	8c 2f       	mov	r24, r28
 b76:	70 de       	rcall	.-800    	; 0x858 <gfx_mono_st7565r_put_byte>
 b78:	d1 50       	subi	r29, 0x01	; 1
 b7a:	a1 f7       	brne	.-24     	; 0xb64 <gfx_mono_generic_draw_horizontal_line+0xbc>
 b7c:	df 91       	pop	r29
 b7e:	cf 91       	pop	r28
 b80:	1f 91       	pop	r17
 b82:	0f 91       	pop	r16
 b84:	ff 90       	pop	r15
 b86:	08 95       	ret

00000b88 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
 b88:	ff 92       	push	r15
 b8a:	0f 93       	push	r16
 b8c:	1f 93       	push	r17
 b8e:	cf 93       	push	r28
 b90:	df 93       	push	r29
 b92:	d8 2f       	mov	r29, r24
 b94:	14 2f       	mov	r17, r20
	if (height == 0) {
 b96:	22 23       	and	r18, r18
 b98:	61 f0       	breq	.+24     	; 0xbb2 <gfx_mono_generic_draw_filled_rect+0x2a>
 b9a:	c2 2f       	mov	r28, r18
 b9c:	ff 24       	eor	r15, r15
 b9e:	fa 94       	dec	r15
 ba0:	f6 0e       	add	r15, r22
 ba2:	6f 2d       	mov	r22, r15
 ba4:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
 ba6:	20 2f       	mov	r18, r16
 ba8:	41 2f       	mov	r20, r17
 baa:	8d 2f       	mov	r24, r29
 bac:	7d df       	rcall	.-262    	; 0xaa8 <gfx_mono_generic_draw_horizontal_line>
 bae:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
 bb0:	c1 f7       	brne	.-16     	; 0xba2 <gfx_mono_generic_draw_filled_rect+0x1a>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
 bb2:	df 91       	pop	r29
 bb4:	cf 91       	pop	r28
 bb6:	1f 91       	pop	r17
 bb8:	0f 91       	pop	r16
 bba:	ff 90       	pop	r15
 bbc:	08 95       	ret

00000bbe <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
 bbe:	af 92       	push	r10
 bc0:	bf 92       	push	r11
 bc2:	cf 92       	push	r12
 bc4:	df 92       	push	r13
 bc6:	ef 92       	push	r14
 bc8:	ff 92       	push	r15
 bca:	0f 93       	push	r16
 bcc:	1f 93       	push	r17
 bce:	cf 93       	push	r28
 bd0:	df 93       	push	r29
 bd2:	c8 2f       	mov	r28, r24
 bd4:	d6 2e       	mov	r13, r22
 bd6:	a4 2e       	mov	r10, r20
 bd8:	79 01       	movw	r14, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
 bda:	00 e0       	ldi	r16, 0x00	; 0
 bdc:	f9 01       	movw	r30, r18
 bde:	24 81       	ldd	r18, Z+4	; 0x04
 be0:	43 81       	ldd	r20, Z+3	; 0x03
 be2:	6a 2d       	mov	r22, r10
 be4:	8d 2d       	mov	r24, r13
 be6:	d0 df       	rcall	.-96     	; 0xb88 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
 be8:	f7 01       	movw	r30, r14
 bea:	90 81       	ld	r25, Z
 bec:	91 11       	cpse	r25, r1
 bee:	39 c0       	rjmp	.+114    	; 0xc62 <gfx_mono_draw_char+0xa4>
	uint8_t i;

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
 bf0:	83 81       	ldd	r24, Z+3	; 0x03
 bf2:	a8 2f       	mov	r26, r24
 bf4:	a6 95       	lsr	r26
 bf6:	a6 95       	lsr	r26
 bf8:	a6 95       	lsr	r26
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
 bfa:	87 70       	andi	r24, 0x07	; 7
 bfc:	09 f0       	breq	.+2      	; 0xc00 <gfx_mono_draw_char+0x42>
		char_row_size++;
 bfe:	af 5f       	subi	r26, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
 c00:	f7 01       	movw	r30, r14
 c02:	c4 80       	ldd	r12, Z+4	; 0x04
 c04:	ac 9d       	mul	r26, r12
 c06:	d0 01       	movw	r26, r0
 c08:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
 c0a:	ec 2f       	mov	r30, r28
 c0c:	f0 e0       	ldi	r31, 0x00	; 0
 c0e:	e7 01       	movw	r28, r14
 c10:	8d 81       	ldd	r24, Y+5	; 0x05
 c12:	e8 1b       	sub	r30, r24
 c14:	f1 09       	sbc	r31, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
 c16:	ae 9f       	mul	r26, r30
 c18:	90 01       	movw	r18, r0
 c1a:	af 9f       	mul	r26, r31
 c1c:	30 0d       	add	r19, r0
 c1e:	be 9f       	mul	r27, r30
 c20:	30 0d       	add	r19, r0
 c22:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
 c24:	09 80       	ldd	r0, Y+1	; 0x01
 c26:	da 81       	ldd	r29, Y+2	; 0x02
 c28:	c0 2d       	mov	r28, r0
 c2a:	c2 0f       	add	r28, r18
 c2c:	d3 1f       	adc	r29, r19
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
 c2e:	f7 01       	movw	r30, r14
 c30:	b3 80       	ldd	r11, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
 c32:	bb 20       	and	r11, r11
 c34:	99 f0       	breq	.+38     	; 0xc5c <gfx_mono_draw_char+0x9e>
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
 c36:	00 e0       	ldi	r16, 0x00	; 0
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
 c38:	10 e0       	ldi	r17, 0x00	; 0
 c3a:	81 2f       	mov	r24, r17
 c3c:	8d 0d       	add	r24, r13
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
 c3e:	91 2f       	mov	r25, r17
 c40:	97 70       	andi	r25, 0x07	; 7
 c42:	19 f4       	brne	.+6      	; 0xc4a <gfx_mono_draw_char+0x8c>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
 c44:	fe 01       	movw	r30, r28
 c46:	04 91       	lpm	r16, Z
				glyph_data++;
 c48:	21 96       	adiw	r28, 0x01	; 1
			}

			if ((glyph_byte & 0x80)) {
 c4a:	00 23       	and	r16, r16
 c4c:	1c f4       	brge	.+6      	; 0xc54 <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
 c4e:	41 e0       	ldi	r20, 0x01	; 1
 c50:	6a 2d       	mov	r22, r10
 c52:	c8 de       	rcall	.-624    	; 0x9e4 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
 c54:	00 0f       	add	r16, r16

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
 c56:	1f 5f       	subi	r17, 0xFF	; 255
 c58:	1b 11       	cpse	r17, r11
 c5a:	ef cf       	rjmp	.-34     	; 0xc3a <gfx_mono_draw_char+0x7c>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
 c5c:	a3 94       	inc	r10
		inc_x = x;
		rows_left--;
 c5e:	ca 94       	dec	r12
	} while (rows_left > 0);
 c60:	31 f7       	brne	.-52     	; 0xc2e <gfx_mono_draw_char+0x70>
#endif
	default:
		/* Unsupported mode, call assert */
		break;
	}
}
 c62:	df 91       	pop	r29
 c64:	cf 91       	pop	r28
 c66:	1f 91       	pop	r17
 c68:	0f 91       	pop	r16
 c6a:	ff 90       	pop	r15
 c6c:	ef 90       	pop	r14
 c6e:	df 90       	pop	r13
 c70:	cf 90       	pop	r12
 c72:	bf 90       	pop	r11
 c74:	af 90       	pop	r10
 c76:	08 95       	ret

00000c78 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
 c78:	df 92       	push	r13
 c7a:	ef 92       	push	r14
 c7c:	ff 92       	push	r15
 c7e:	0f 93       	push	r16
 c80:	1f 93       	push	r17
 c82:	cf 93       	push	r28
 c84:	df 93       	push	r29
 c86:	e4 2e       	mov	r14, r20
 c88:	89 01       	movw	r16, r18
 c8a:	ec 01       	movw	r28, r24
 c8c:	f6 2e       	mov	r15, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
 c8e:	d6 2e       	mov	r13, r22
	const gfx_coord_t start_of_string_position_x = x;

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
 c90:	89 91       	ld	r24, Y+
 c92:	8a 30       	cpi	r24, 0x0A	; 10
 c94:	31 f4       	brne	.+12     	; 0xca2 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
 c96:	f8 01       	movw	r30, r16
 c98:	84 81       	ldd	r24, Z+4	; 0x04
 c9a:	8f 5f       	subi	r24, 0xFF	; 255
 c9c:	e8 0e       	add	r14, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
 c9e:	fd 2c       	mov	r15, r13
 ca0:	09 c0       	rjmp	.+18     	; 0xcb4 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
 ca2:	8d 30       	cpi	r24, 0x0D	; 13
 ca4:	39 f0       	breq	.+14     	; 0xcb4 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
 ca6:	98 01       	movw	r18, r16
 ca8:	4e 2d       	mov	r20, r14
 caa:	6f 2d       	mov	r22, r15
 cac:	88 df       	rcall	.-240    	; 0xbbe <gfx_mono_draw_char>
			x += font->width;
 cae:	f8 01       	movw	r30, r16
 cb0:	83 81       	ldd	r24, Z+3	; 0x03
 cb2:	f8 0e       	add	r15, r24
		}
	} while (*(++str));
 cb4:	88 81       	ld	r24, Y
 cb6:	81 11       	cpse	r24, r1
 cb8:	eb cf       	rjmp	.-42     	; 0xc90 <gfx_mono_draw_string+0x18>
}
 cba:	df 91       	pop	r29
 cbc:	cf 91       	pop	r28
 cbe:	1f 91       	pop	r17
 cc0:	0f 91       	pop	r16
 cc2:	ff 90       	pop	r15
 cc4:	ef 90       	pop	r14
 cc6:	df 90       	pop	r13
 cc8:	08 95       	ret

00000cca <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
 cca:	cf 93       	push	r28
 ccc:	df 93       	push	r29
 * \note this functions should not be confused with the \ref st7565r_soft_reset()
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ST7565R_RESET_PORT.OUTCLR = ST7565R_RESET_PIN;
 cce:	88 e0       	ldi	r24, 0x08	; 8
 cd0:	e0 e0       	ldi	r30, 0x00	; 0
 cd2:	f6 e0       	ldi	r31, 0x06	; 6
 cd4:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 cd6:	8a e6       	ldi	r24, 0x6A	; 106
 cd8:	8a 95       	dec	r24
 cda:	f1 f7       	brne	.-4      	; 0xcd8 <st7565r_init+0xe>
 cdc:	00 c0       	rjmp	.+0      	; 0xcde <st7565r_init+0x14>
	_delay_us(10);
	ST7565R_RESET_PORT.OUTSET = ST7565R_RESET_PIN;
 cde:	88 e0       	ldi	r24, 0x08	; 8
 ce0:	85 83       	std	Z+5, r24	; 0x05
 ce2:	ca e6       	ldi	r28, 0x6A	; 106
 ce4:	ca 95       	dec	r28
 ce6:	f1 f7       	brne	.-4      	; 0xce4 <st7565r_init+0x1a>
 ce8:	00 c0       	rjmp	.+0      	; 0xcea <st7565r_init+0x20>
 * Depending on what interface used for interfacing the LCD controller this
 * function will initialize the necessary hardware.
 */
static void st7565r_interface_init(void)
{
	ST7565R_MOSI_PORT.DIRSET = ST7565R_MOSI_PIN | ST7565R_SCK_PIN | ST7565R_A0_PIN;
 cea:	e0 e6       	ldi	r30, 0x60	; 96
 cec:	f6 e0       	ldi	r31, 0x06	; 6
 cee:	3b e0       	ldi	r19, 0x0B	; 11
 cf0:	31 83       	std	Z+1, r19	; 0x01
	ST7565R_CS_PORT.DIRSET = ST7565R_CS_PIN;
 cf2:	a0 ea       	ldi	r26, 0xA0	; 160
 cf4:	b6 e0       	ldi	r27, 0x06	; 6
 cf6:	28 e0       	ldi	r18, 0x08	; 8
 cf8:	11 96       	adiw	r26, 0x01	; 1
 cfa:	2c 93       	st	X, r18
 cfc:	11 97       	sbiw	r26, 0x01	; 1
	ST7565R_RESET_PORT.DIRSET = ST7565R_RESET_PIN;
 cfe:	60 e0       	ldi	r22, 0x00	; 0
 d00:	76 e0       	ldi	r23, 0x06	; 6
 d02:	eb 01       	movw	r28, r22
 d04:	29 83       	std	Y+1, r18	; 0x01
	ST7565R_BACKLIGHT_PORT.DIRSET = ST7565R_BACKLIGHT_PIN;
 d06:	40 e1       	ldi	r20, 0x10	; 16
 d08:	80 e8       	ldi	r24, 0x80	; 128
 d0a:	96 e0       	ldi	r25, 0x06	; 6
 d0c:	ec 01       	movw	r28, r24
 d0e:	49 83       	std	Y+1, r20	; 0x01
	ST7565R_MOSI_PORT.OUTSET = ST7565R_MOSI_PIN | ST7565R_SCK_PIN | ST7565R_A0_PIN;
 d10:	35 83       	std	Z+5, r19	; 0x05
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 d12:	15 96       	adiw	r26, 0x05	; 5
 d14:	2c 93       	st	X, r18
 d16:	15 97       	sbiw	r26, 0x05	; 5
	ST7565R_RESET_PORT.OUTSET = ST7565R_RESET_PIN;
 d18:	eb 01       	movw	r28, r22
 d1a:	2d 83       	std	Y+5, r18	; 0x05
	
	ST7565R_USART_SPI.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
 d1c:	c0 ea       	ldi	r28, 0xA0	; 160
 d1e:	d9 e0       	ldi	r29, 0x09	; 9
 d20:	88 e1       	ldi	r24, 0x18	; 24
 d22:	8c 83       	std	Y+4, r24	; 0x04
	ST7565R_USART_SPI.CTRLC |= USART_CMODE_MSPI_gc;
 d24:	8d 81       	ldd	r24, Y+5	; 0x05
 d26:	80 6c       	ori	r24, 0xC0	; 192
 d28:	8d 83       	std	Y+5, r24	; 0x05
	// Initialize the interface
	st7565r_interface_init();

	// Set the A0 pin to the default state (command)
	//ioport_set_pin_low(ST7565R_A0_PIN);
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 d2a:	81 e0       	ldi	r24, 0x01	; 1
 d2c:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 d2e:	16 96       	adiw	r26, 0x06	; 6
 d30:	2c 93       	st	X, r18
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 d32:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 d34:	e0 ea       	ldi	r30, 0xA0	; 160
 d36:	f9 e0       	ldi	r31, 0x09	; 9
 d38:	81 81       	ldd	r24, Z+1	; 0x01
 d3a:	85 ff       	sbrs	r24, 5
 d3c:	fd cf       	rjmp	.-6      	; 0xd38 <st7565r_init+0x6e>
	ST7565R_USART_SPI.DATA = command;
 d3e:	80 ea       	ldi	r24, 0xA0	; 160
 d40:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 d44:	e0 ea       	ldi	r30, 0xA0	; 160
 d46:	f9 e0       	ldi	r31, 0x09	; 9
 d48:	81 81       	ldd	r24, Z+1	; 0x01
 d4a:	86 ff       	sbrs	r24, 6
 d4c:	fd cf       	rjmp	.-6      	; 0xd48 <st7565r_init+0x7e>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 d4e:	e0 ea       	ldi	r30, 0xA0	; 160
 d50:	f9 e0       	ldi	r31, 0x09	; 9
 d52:	81 81       	ldd	r24, Z+1	; 0x01
 d54:	80 64       	ori	r24, 0x40	; 64
 d56:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 d58:	80 81       	ld	r24, Z
 d5a:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 d5e:	e0 ea       	ldi	r30, 0xA0	; 160
 d60:	f6 e0       	ldi	r31, 0x06	; 6
 d62:	88 e0       	ldi	r24, 0x08	; 8
 d64:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 d66:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 d68:	81 e0       	ldi	r24, 0x01	; 1
 d6a:	e0 e6       	ldi	r30, 0x60	; 96
 d6c:	f6 e0       	ldi	r31, 0x06	; 6
 d6e:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 d70:	e0 ea       	ldi	r30, 0xA0	; 160
 d72:	f9 e0       	ldi	r31, 0x09	; 9
 d74:	81 81       	ldd	r24, Z+1	; 0x01
 d76:	85 ff       	sbrs	r24, 5
 d78:	fd cf       	rjmp	.-6      	; 0xd74 <st7565r_init+0xaa>
	ST7565R_USART_SPI.DATA = command;
 d7a:	86 ea       	ldi	r24, 0xA6	; 166
 d7c:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 d80:	e0 ea       	ldi	r30, 0xA0	; 160
 d82:	f9 e0       	ldi	r31, 0x09	; 9
 d84:	81 81       	ldd	r24, Z+1	; 0x01
 d86:	86 ff       	sbrs	r24, 6
 d88:	fd cf       	rjmp	.-6      	; 0xd84 <st7565r_init+0xba>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 d8a:	e0 ea       	ldi	r30, 0xA0	; 160
 d8c:	f9 e0       	ldi	r31, 0x09	; 9
 d8e:	81 81       	ldd	r24, Z+1	; 0x01
 d90:	80 64       	ori	r24, 0x40	; 64
 d92:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 d94:	80 81       	ld	r24, Z
 d96:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 d9a:	e0 ea       	ldi	r30, 0xA0	; 160
 d9c:	f6 e0       	ldi	r31, 0x06	; 6
 d9e:	88 e0       	ldi	r24, 0x08	; 8
 da0:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 da2:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 da4:	81 e0       	ldi	r24, 0x01	; 1
 da6:	e0 e6       	ldi	r30, 0x60	; 96
 da8:	f6 e0       	ldi	r31, 0x06	; 6
 daa:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 dac:	e0 ea       	ldi	r30, 0xA0	; 160
 dae:	f9 e0       	ldi	r31, 0x09	; 9
 db0:	81 81       	ldd	r24, Z+1	; 0x01
 db2:	85 ff       	sbrs	r24, 5
 db4:	fd cf       	rjmp	.-6      	; 0xdb0 <st7565r_init+0xe6>
	ST7565R_USART_SPI.DATA = command;
 db6:	88 ec       	ldi	r24, 0xC8	; 200
 db8:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 dbc:	e0 ea       	ldi	r30, 0xA0	; 160
 dbe:	f9 e0       	ldi	r31, 0x09	; 9
 dc0:	81 81       	ldd	r24, Z+1	; 0x01
 dc2:	86 ff       	sbrs	r24, 6
 dc4:	fd cf       	rjmp	.-6      	; 0xdc0 <st7565r_init+0xf6>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 dc6:	e0 ea       	ldi	r30, 0xA0	; 160
 dc8:	f9 e0       	ldi	r31, 0x09	; 9
 dca:	81 81       	ldd	r24, Z+1	; 0x01
 dcc:	80 64       	ori	r24, 0x40	; 64
 dce:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 dd0:	80 81       	ld	r24, Z
 dd2:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 dd6:	e0 ea       	ldi	r30, 0xA0	; 160
 dd8:	f6 e0       	ldi	r31, 0x06	; 6
 dda:	88 e0       	ldi	r24, 0x08	; 8
 ddc:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 dde:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 de0:	81 e0       	ldi	r24, 0x01	; 1
 de2:	e0 e6       	ldi	r30, 0x60	; 96
 de4:	f6 e0       	ldi	r31, 0x06	; 6
 de6:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 de8:	e0 ea       	ldi	r30, 0xA0	; 160
 dea:	f9 e0       	ldi	r31, 0x09	; 9
 dec:	81 81       	ldd	r24, Z+1	; 0x01
 dee:	85 ff       	sbrs	r24, 5
 df0:	fd cf       	rjmp	.-6      	; 0xdec <st7565r_init+0x122>
	ST7565R_USART_SPI.DATA = command;
 df2:	82 ea       	ldi	r24, 0xA2	; 162
 df4:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 df8:	e0 ea       	ldi	r30, 0xA0	; 160
 dfa:	f9 e0       	ldi	r31, 0x09	; 9
 dfc:	81 81       	ldd	r24, Z+1	; 0x01
 dfe:	86 ff       	sbrs	r24, 6
 e00:	fd cf       	rjmp	.-6      	; 0xdfc <st7565r_init+0x132>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 e02:	e0 ea       	ldi	r30, 0xA0	; 160
 e04:	f9 e0       	ldi	r31, 0x09	; 9
 e06:	81 81       	ldd	r24, Z+1	; 0x01
 e08:	80 64       	ori	r24, 0x40	; 64
 e0a:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 e0c:	80 81       	ld	r24, Z
 e0e:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 e12:	e0 ea       	ldi	r30, 0xA0	; 160
 e14:	f6 e0       	ldi	r31, 0x06	; 6
 e16:	88 e0       	ldi	r24, 0x08	; 8
 e18:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 e1a:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 e1c:	81 e0       	ldi	r24, 0x01	; 1
 e1e:	e0 e6       	ldi	r30, 0x60	; 96
 e20:	f6 e0       	ldi	r31, 0x06	; 6
 e22:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 e24:	e0 ea       	ldi	r30, 0xA0	; 160
 e26:	f9 e0       	ldi	r31, 0x09	; 9
 e28:	81 81       	ldd	r24, Z+1	; 0x01
 e2a:	85 ff       	sbrs	r24, 5
 e2c:	fd cf       	rjmp	.-6      	; 0xe28 <st7565r_init+0x15e>
	ST7565R_USART_SPI.DATA = command;
 e2e:	8f e2       	ldi	r24, 0x2F	; 47
 e30:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 e34:	e0 ea       	ldi	r30, 0xA0	; 160
 e36:	f9 e0       	ldi	r31, 0x09	; 9
 e38:	81 81       	ldd	r24, Z+1	; 0x01
 e3a:	86 ff       	sbrs	r24, 6
 e3c:	fd cf       	rjmp	.-6      	; 0xe38 <st7565r_init+0x16e>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 e3e:	e0 ea       	ldi	r30, 0xA0	; 160
 e40:	f9 e0       	ldi	r31, 0x09	; 9
 e42:	81 81       	ldd	r24, Z+1	; 0x01
 e44:	80 64       	ori	r24, 0x40	; 64
 e46:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 e48:	80 81       	ld	r24, Z
 e4a:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 e4e:	e0 ea       	ldi	r30, 0xA0	; 160
 e50:	f6 e0       	ldi	r31, 0x06	; 6
 e52:	88 e0       	ldi	r24, 0x08	; 8
 e54:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 e56:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 e58:	81 e0       	ldi	r24, 0x01	; 1
 e5a:	e0 e6       	ldi	r30, 0x60	; 96
 e5c:	f6 e0       	ldi	r31, 0x06	; 6
 e5e:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 e60:	e0 ea       	ldi	r30, 0xA0	; 160
 e62:	f9 e0       	ldi	r31, 0x09	; 9
 e64:	81 81       	ldd	r24, Z+1	; 0x01
 e66:	85 ff       	sbrs	r24, 5
 e68:	fd cf       	rjmp	.-6      	; 0xe64 <st7565r_init+0x19a>
	ST7565R_USART_SPI.DATA = command;
 e6a:	88 ef       	ldi	r24, 0xF8	; 248
 e6c:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 e70:	e0 ea       	ldi	r30, 0xA0	; 160
 e72:	f9 e0       	ldi	r31, 0x09	; 9
 e74:	81 81       	ldd	r24, Z+1	; 0x01
 e76:	86 ff       	sbrs	r24, 6
 e78:	fd cf       	rjmp	.-6      	; 0xe74 <st7565r_init+0x1aa>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 e7a:	e0 ea       	ldi	r30, 0xA0	; 160
 e7c:	f9 e0       	ldi	r31, 0x09	; 9
 e7e:	81 81       	ldd	r24, Z+1	; 0x01
 e80:	80 64       	ori	r24, 0x40	; 64
 e82:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 e84:	80 81       	ld	r24, Z
 e86:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 e8a:	e0 ea       	ldi	r30, 0xA0	; 160
 e8c:	f6 e0       	ldi	r31, 0x06	; 6
 e8e:	88 e0       	ldi	r24, 0x08	; 8
 e90:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 e92:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 e94:	81 e0       	ldi	r24, 0x01	; 1
 e96:	e0 e6       	ldi	r30, 0x60	; 96
 e98:	f6 e0       	ldi	r31, 0x06	; 6
 e9a:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 e9c:	e0 ea       	ldi	r30, 0xA0	; 160
 e9e:	f9 e0       	ldi	r31, 0x09	; 9
 ea0:	81 81       	ldd	r24, Z+1	; 0x01
 ea2:	85 ff       	sbrs	r24, 5
 ea4:	fd cf       	rjmp	.-6      	; 0xea0 <st7565r_init+0x1d6>
	ST7565R_USART_SPI.DATA = command;
 ea6:	10 92 a0 09 	sts	0x09A0, r1
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 eaa:	e0 ea       	ldi	r30, 0xA0	; 160
 eac:	f9 e0       	ldi	r31, 0x09	; 9
 eae:	81 81       	ldd	r24, Z+1	; 0x01
 eb0:	86 ff       	sbrs	r24, 6
 eb2:	fd cf       	rjmp	.-6      	; 0xeae <st7565r_init+0x1e4>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 eb4:	e0 ea       	ldi	r30, 0xA0	; 160
 eb6:	f9 e0       	ldi	r31, 0x09	; 9
 eb8:	81 81       	ldd	r24, Z+1	; 0x01
 eba:	80 64       	ori	r24, 0x40	; 64
 ebc:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 ebe:	80 81       	ld	r24, Z
 ec0:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 ec4:	e0 ea       	ldi	r30, 0xA0	; 160
 ec6:	f6 e0       	ldi	r31, 0x06	; 6
 ec8:	88 e0       	ldi	r24, 0x08	; 8
 eca:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 ecc:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 ece:	81 e0       	ldi	r24, 0x01	; 1
 ed0:	e0 e6       	ldi	r30, 0x60	; 96
 ed2:	f6 e0       	ldi	r31, 0x06	; 6
 ed4:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 ed6:	e0 ea       	ldi	r30, 0xA0	; 160
 ed8:	f9 e0       	ldi	r31, 0x09	; 9
 eda:	81 81       	ldd	r24, Z+1	; 0x01
 edc:	85 ff       	sbrs	r24, 5
 ede:	fd cf       	rjmp	.-6      	; 0xeda <st7565r_init+0x210>
	ST7565R_USART_SPI.DATA = command;
 ee0:	81 e2       	ldi	r24, 0x21	; 33
 ee2:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 ee6:	e0 ea       	ldi	r30, 0xA0	; 160
 ee8:	f9 e0       	ldi	r31, 0x09	; 9
 eea:	81 81       	ldd	r24, Z+1	; 0x01
 eec:	86 ff       	sbrs	r24, 6
 eee:	fd cf       	rjmp	.-6      	; 0xeea <st7565r_init+0x220>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 ef0:	e0 ea       	ldi	r30, 0xA0	; 160
 ef2:	f9 e0       	ldi	r31, 0x09	; 9
 ef4:	81 81       	ldd	r24, Z+1	; 0x01
 ef6:	80 64       	ori	r24, 0x40	; 64
 ef8:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 efa:	80 81       	ld	r24, Z
 efc:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 f00:	e0 ea       	ldi	r30, 0xA0	; 160
 f02:	f6 e0       	ldi	r31, 0x06	; 6
 f04:	88 e0       	ldi	r24, 0x08	; 8
 f06:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 f08:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 f0a:	81 e0       	ldi	r24, 0x01	; 1
 f0c:	e0 e6       	ldi	r30, 0x60	; 96
 f0e:	f6 e0       	ldi	r31, 0x06	; 6
 f10:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 f12:	e0 ea       	ldi	r30, 0xA0	; 160
 f14:	f9 e0       	ldi	r31, 0x09	; 9
 f16:	81 81       	ldd	r24, Z+1	; 0x01
 f18:	85 ff       	sbrs	r24, 5
 f1a:	fd cf       	rjmp	.-6      	; 0xf16 <st7565r_init+0x24c>
	ST7565R_USART_SPI.DATA = command;
 f1c:	81 e8       	ldi	r24, 0x81	; 129
 f1e:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 f22:	e0 ea       	ldi	r30, 0xA0	; 160
 f24:	f9 e0       	ldi	r31, 0x09	; 9
 f26:	81 81       	ldd	r24, Z+1	; 0x01
 f28:	86 ff       	sbrs	r24, 6
 f2a:	fd cf       	rjmp	.-6      	; 0xf26 <st7565r_init+0x25c>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 f2c:	e0 ea       	ldi	r30, 0xA0	; 160
 f2e:	f9 e0       	ldi	r31, 0x09	; 9
 f30:	81 81       	ldd	r24, Z+1	; 0x01
 f32:	80 64       	ori	r24, 0x40	; 64
 f34:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 f36:	80 81       	ld	r24, Z
 f38:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 f3c:	e0 ea       	ldi	r30, 0xA0	; 160
 f3e:	f6 e0       	ldi	r31, 0x06	; 6
 f40:	88 e0       	ldi	r24, 0x08	; 8
 f42:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 f44:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 f46:	81 e0       	ldi	r24, 0x01	; 1
 f48:	e0 e6       	ldi	r30, 0x60	; 96
 f4a:	f6 e0       	ldi	r31, 0x06	; 6
 f4c:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 f4e:	e0 ea       	ldi	r30, 0xA0	; 160
 f50:	f9 e0       	ldi	r31, 0x09	; 9
 f52:	81 81       	ldd	r24, Z+1	; 0x01
 f54:	85 ff       	sbrs	r24, 5
 f56:	fd cf       	rjmp	.-6      	; 0xf52 <st7565r_init+0x288>
	ST7565R_USART_SPI.DATA = command;
 f58:	81 e2       	ldi	r24, 0x21	; 33
 f5a:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 f5e:	e0 ea       	ldi	r30, 0xA0	; 160
 f60:	f9 e0       	ldi	r31, 0x09	; 9
 f62:	81 81       	ldd	r24, Z+1	; 0x01
 f64:	86 ff       	sbrs	r24, 6
 f66:	fd cf       	rjmp	.-6      	; 0xf62 <st7565r_init+0x298>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 f68:	e0 ea       	ldi	r30, 0xA0	; 160
 f6a:	f9 e0       	ldi	r31, 0x09	; 9
 f6c:	81 81       	ldd	r24, Z+1	; 0x01
 f6e:	80 64       	ori	r24, 0x40	; 64
 f70:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 f72:	80 81       	ld	r24, Z
 f74:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 f78:	e0 ea       	ldi	r30, 0xA0	; 160
 f7a:	f6 e0       	ldi	r31, 0x06	; 6
 f7c:	88 e0       	ldi	r24, 0x08	; 8
 f7e:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
	ST7565R_CS_PORT.OUTCLR = ST7565R_CS_PIN;
 f80:	86 83       	std	Z+6, r24	; 0x06
	ST7565R_A0_PORT.OUTCLR = ST7565R_A0_PIN;
 f82:	81 e0       	ldi	r24, 0x01	; 1
 f84:	e0 e6       	ldi	r30, 0x60	; 96
 f86:	f6 e0       	ldi	r31, 0x06	; 6
 f88:	86 83       	std	Z+6, r24	; 0x06
	while(!(ST7565R_USART_SPI.STATUS & USART_DREIF_bm));
 f8a:	e0 ea       	ldi	r30, 0xA0	; 160
 f8c:	f9 e0       	ldi	r31, 0x09	; 9
 f8e:	81 81       	ldd	r24, Z+1	; 0x01
 f90:	85 ff       	sbrs	r24, 5
 f92:	fd cf       	rjmp	.-6      	; 0xf8e <st7565r_init+0x2c4>
	ST7565R_USART_SPI.DATA = command;
 f94:	8f ea       	ldi	r24, 0xAF	; 175
 f96:	80 93 a0 09 	sts	0x09A0, r24
	while(!(ST7565R_USART_SPI.STATUS & USART_TXCIF_bm));
 f9a:	e0 ea       	ldi	r30, 0xA0	; 160
 f9c:	f9 e0       	ldi	r31, 0x09	; 9
 f9e:	81 81       	ldd	r24, Z+1	; 0x01
 fa0:	86 ff       	sbrs	r24, 6
 fa2:	fd cf       	rjmp	.-6      	; 0xf9e <st7565r_init+0x2d4>
	ST7565R_USART_SPI.STATUS |= USART_TXCIF_bm;
 fa4:	e0 ea       	ldi	r30, 0xA0	; 160
 fa6:	f9 e0       	ldi	r31, 0x09	; 9
 fa8:	81 81       	ldd	r24, Z+1	; 0x01
 faa:	80 64       	ori	r24, 0x40	; 64
 fac:	81 83       	std	Z+1, r24	; 0x01
	temp = ST7565R_USART_SPI.DATA;
 fae:	80 81       	ld	r24, Z
 fb0:	80 93 ff 22 	sts	0x22FF, r24
	ST7565R_CS_PORT.OUTSET = ST7565R_CS_PIN;
 fb4:	88 e0       	ldi	r24, 0x08	; 8
 fb6:	e0 ea       	ldi	r30, 0xA0	; 160
 fb8:	f6 e0       	ldi	r31, 0x06	; 6
 fba:	85 83       	std	Z+5, r24	; 0x05
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
 fbc:	df 91       	pop	r29
 fbe:	cf 91       	pop	r28
 fc0:	08 95       	ret

00000fc2 <_exit>:
 fc2:	f8 94       	cli

00000fc4 <__stop_program>:
 fc4:	ff cf       	rjmp	.-2      	; 0xfc4 <__stop_program>
